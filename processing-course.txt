Learning Processing, 10 years later. Take one. Do you have no idea what it means to program? That is going way too fast. 

[TEST TONE] 

Take two. Totally just pressed the wrong button on the teleprompter. 

[TEST TONE] 

Take three. I'm really going to get this intro this time. 

Hi. Welcome. First, this is a really long video. I'm about to introduce it, and talk about myself, my background, and what's going to be here. But if you kind of know why you're here already, and you just want to get to the tutorials, check the time codes in the video description. You can jump right there. 

But maybe you have no idea why you're here. If that's the case, I would really like to know. So why am I here making this video? Have you ever wanted to learn programming? 

Do you have no idea what it means to program, to write code, to create your own software? Do you want to break free from the bonds of the tools that other people have made you and learn to build your own software, to make things with code? So that kind of sounds like a sales pitch. That was not my intention. 

I'm not trying to sell anything here. You can go. You can leave. There's lots of other recommendations and things that will probably take you somewhere else. 

But if I've piqued your interest. If you're interested in learning to program, this is why I'm making this very long video series-- full tutorial about learning to code. When you first start learning to code, trying to pick a programming language to use, an environment, figuring out what you want to make, it's a giant complicated mess of questions and possibilities. 

It can be very hard to get started. So I'm going to take care of all of that for you right now. And there's one way that you can learn how to program. Not the only way-- not the only way you can or should, but it's my favorite way, and that's with something called Processing. 

I have been working with Processing since 2003. I have made a lot of online tutorials, and textbooks, and lots of workshops, and classes. And in fact, in 2012, I was teaching a class called Introduction to computational media, and I started making a video about how to learn to code with Processing. 

And it was just as messy and confused as I am right now, but this is who I am. Take it or leave it. It'll get, hopefully, a little bit more focused and organized once I'm into the actual coding lessons itself. 

So I really was just asking myself the question, should I remake those videos? The quality wasn't so great, although I did look much younger over 10 years ago. But enough time has passed. 

A lot has changed in the landscape of tools for learning to code. I've learned some new better ways to teach some of the concepts. Processing most recently came out with version 4, which has many new and exciting features. I have a lot more gray hair. I got these like stripes here. 

So I figure, why not let's just do it all again? So it's my hope that this video will help you learn to code for the very first time. I mean, I suppose you could watch this if you already know how to code, but I'm really looking for the beginner. 

I'm about to get started, but I want to talk to you a little bit more about just sort of me, and my background, and also a little bit about-- if you'll indulge me-- the history of Processing itself. So I think I said my name. If I didn't, it's Dan. Daniel Shiffman is also another way to say my name in a longer way. 

I work and teach currently at a program called ITP and IMA, which is part of Tisch School of the Arts at New York University. And that is, in fact, where I discovered that I love programming. I was 28 years old. It was 2001, and I enrolled as a master's student in this program, ITP, where I teach now. 

And I took a class called Introduction to computational media, and I learned the basics of programming with the LINGO programming language. You might not know what LINGO is, but it is the programming language from a piece of software called Macromedia Director, and it was invented by the incredible John Henry Thompson. So I encourage you to learn more about John Henry Thompson's work. 

He actually appeared as a guest on a Coding Train video. I'll show a clip of that right now. You can watch that. But the point of what I'm trying to say here, that you might be surprised to know, is that beyond some small experiments I did programming on an Apple II in the '80s, as a kid, I never actually got interested in programming until that time. 

I was interested in other things, and maybe you are too. What is your passion? Maybe you're interested in biology, or economics, or painting, or robots, music, movies, hiking, social justice, the law, travel, sociology, dance, food. Do you like to cook? I don't know. 

I'm here to tell you that learning to code is something that you can do, and it may just expand the way you approach and think about whatever the passions are in your life. So I think there is this question of, why should you learn to program the computer? And the first thing that I think is important to say is, maybe you don't need to or want to. 

That's totally fine. You're interested in lots of stuff. This does not interest you. Other videos to watch, other skills learn. No problem. 

I don't mean to say that everyone needs to learn to program, or certainly everyone should watch this video to learn to program. But if you're interested, and you think you might want to learn to program, then I want to say that it is for you. There are no restrictions, no prior knowledge. It's really something that everybody can do. 

And here's why I think it might be relevant. Like you probably-- I mean, you're watching this video probably on a computer. You probably use the computer a lot. 

Maybe you use it as a tool for work, for family and social interactions. You do your taxes on it, you use different software, you want to write an essay, you need to manipulate an image. So much of the stuff you do in your life requires a computer. 

So what are you using on the computer? You're using software. Who made the software? Not you. I mean, it's great that there is all this software, but if you want to be creative, if you want to express yourself, if you want to make your own things on the computer without the limitations and features that other people who have made the software from particular large corporations that are selling you the software, then you will want to learn to code. 

Everything that you do on the computer starts with that software. So why can't the person who makes the software to do the things on your computer be you? What kinds of things could you invent? What kinds of ideas could you come up with if you weren't limited by what already runs on your computer. 

Now, I have to admit something. I'm making this sound very, very grand. And in just a short while, as I start doing the tutorials, we're going to be really excited because you and I, together, writing some code drew a circle that appeared on the screen. 

So don't get me wrong. This is going to be a slow process. Programming is hard, and this is just the beginning. I'm going to show you the basics, and you're going to need to take it much farther. But it's my hope that this video series will get you going in the right direction. 

So how am I going to show you about code? How are you going to learn to code. So honestly, I really wish that I knew the secret-- the perfect way for everyone to learn. I don't. 

And I'm the first to admit that my style of presentation might not be the right fit for you. There are lots of online resources, books, and videos. How do you know what to pick? 

In my view, the best way to learn programming is to try learning the programming language that's right in front of you. What do I mean by right in front of you? I mean, maybe you have a friend who's also learning to program. 

Why don't you just learn the same language that they're learning so you can do it together? Maybe you've had a teacher who you just find inspiring, and they love this language, and they've got some lessons in this language. Try that one. Don't worry too much. 

Ultimately, to learn, you're just going to have to try it yourself. I could try to build a very fancy online learning platform, but nothing beats being with people and talking through those ideas. Nothing beats learning from your mistakes and asking for help, and even better, helping others. 

So maybe-- maybe this video and me-- I can be that person for you on some level. Maybe Processing can be that platform for you. It was for me. 

And so I'm really excited to share my experience learning to code with you. It was right around-- I learned with LINGO, as I talked about. I was learning Java and some other programming languages. And right around the time I graduated from this program in 2003, I discovered Processing, and immediately started learning everything I could about it. 

In 2004, I taught a class called procedural painting as an experiment to a small group of students at NYU. And there, I attempted to take everything I had learned in LINGO and translate it into the Processing environment. So that syllabus and set of tutorials made their way into a book called Learning Processing, which then made their way into the 2012 video series about learning to code, and launched, ultimately, this YouTube channel called the Coding Train, which is where I am right now. 

And I hope that this video will be the new one on the channel to help everybody get started learning to program with Processing. Let me give you a quick primer on the history of the Processing project. So it began in June, 2001. 

Casey Reas and Ben Fry were studying under John Maeda at the MIT Media Lab. Now, Maeda had created something called Design By Numbers, and they were inspired by it. Design By Numbers emphasized simplicity in creating images and animations with code, and Reas and Fry wanted to do something similar. 

They wanted to make an environment that would match the ease of beginner-friendly languages, like BASIC and Logo. In a 2009 rhizome.org interview, Fry explains, our goal was to emulate Design By Numbers simplicity and focus, but we wanted to exceed the limits of DBN. So Design By Numbers could only render a 100 by 100 pixels, it was all grayscale, it only allowed for integer whole numbers. 

So Reas and Fry settled on using the programming language Java to build a new Processing environment, which would allow for full color, higher resolution. But because it was Java, it could also connect to this giant world of packages and libraries. So Processing programs could a gate on the network, that could interface with hardware and microcontrollers, they could render graphics to a PDF, and so much more. 

The name Processing actually comes from a journal idea that Reas and Fry were considering publishing with the MIT Press. They wanted to write about computational work and the process behind it. The journal never happened, but the Processing name did stick. 

You might be amused to know that other names that were tossed around, I think, were Seal and Bagel. I really like the idea of bagel, actually. 

So Processing 1.0 was released in 2008. And in 2012, the Processing Foundation itself, a nonprofit, was formed with a mission to maintain the software platforms and support people in learning how to program, especially those who might not otherwise have access to tools and resources. The foundation has expanded its offerings. 

There's Python mode for Processing, created by Jonathan Feinberg, Processing for Android created by Andres Colubris, and p5.js created by Lauren Lee McCarthy. If you've watched the Coding Train before, you've probably seen me use both Processing and p5.js across countless tutorials and coding challenges. 

With p5.js, I'm able to link to the code running in the browser right there because it's JavaScript. You might be surprised to know that while Java today seems like the farthest thing away from the web browser, in 2001, Java applets were the primary way to share Processing sketches on the web. So Java applets are no longer supported today, but the newest version of Processing, Processing 4, which I am celebrating in this series, includes many new features well-suited for desktop applications. 

So full-screen graphics across different screens and projectors, connecting to third-party libraries, hardware, and more. So whether you want to use Processing, explore JavaScript, or Python, or try your hand at any other language or environment, it's my hope that Processing 4 is a place for you to learn and play. The concepts, the fundamentals, the core principles of coding are the same across all of these places. 

Beyond learning a specific language, I think what's important about learning to program is learning about how to think about a problem and break it down into parts and solve it. And let me tell you, when it works, it is very, very satisfying. So now, it's time to get into this video itself. 

I want to talk to you a bit about how I've structured things, how you might watch and move your way through what is a very, very long video. So ordinarily, in the past, I've made courses, or video tutorials, or sequences like this broken up into many, many, many short videos, 10 to 20 minutes each. This is everything all in one. 

It is not meant to be consumed in one sitting. I've divided it into different chapters, organized with a table of contents. I'll include information about that in the video description on my website. But hopefully, if you're watching this on YouTube, you are seeing that as part of the interface-- the experience of watching it. 

So it's a bunch of lessons, all sequenced, teaching you the fundamentals of computer science and programming with Processing. And at the end, everything culminates with a mini-project that I'll show you how to build that synthesizes all of the concepts from the series. While the video is going, I will prompt you to take breaks, I'll offer exercises. 

It is meant to be watched in order, but there's no reason why you couldn't skip around. Find your place using the time code links. Maybe you want to skip some things, reinforce other things. I leave that up to you. 

All of the code that I write-- everything will be at the codingtrain.com. You'll find the links in the video description. Now, what are you going to learn exactly? My approach is probably different than a traditional computer science course. 

Certainly, there's no tests here. I mean, this is all self-directed self-learning. But the goal here is for you to experiment and play. It's OK for you to not understand everything, to have those happy accidents, to move forwards and backwards, and just discover what it is that you're interested in trying to make without worrying about it too much. 

You will need help. There's no way to just learn all this stuff just completely on your own without talking to another human being. So maybe you have a support system for yourself, maybe you have some friends you're learning with. maybe you're taking a class. 

I'm not sure, but if you don't, I certainly would encourage you to use the comments here or whatever platform you're watching this on. But the place for you to get help, in terms of the Coding Train community, is the Coding Train Discord itself. I'll put the URL for how you join and, obviously, in the video description as well. 

That's it. That's all I've got for you before it's time to get started! It's time to get started! You're going to write your first line of code! Thank you for watching, thank you for being here. I can't wait to see what you learn, what you make, and what you think of this series. 

[MUSIC PLAYING] 

I am now going to show you how to download Processing onto your computer, which you will need to do before you start following the coding portions of this video. I should also say that I've been recording this whole long video at different times on different days, so my outfit, and clothes, and lighting might change here and there. So I apologize for that, but hopefully, you'll be able to follow. 

It's going to all be pieced together in the perfect way that let's you just follow it all the way through. But the part you're at right now is downloading Processing. So you will need a computer. It can be Windows, Mac, Linux. Those are the computers that support Processing. 

You're going to want to go to processing.org. And there's a lot on the Processing website that you can look at. I'm going to very specifically cover quite a bit about the reference under documentation, but I certainly would encourage you to go to the tutorials, examples, books, learn more about the people, et cetera, et cetera. 

But here, right now, what I want to look at with you is download. So the page should auto-detect the version it thinks you should download, and it is correct for me. I want Processing 4.2 on macOS. 

You will actually probably see me using Processing 4.1.2 or 1.3 when I'm doing the coding, because I've recorded those already. But what you will see is either 4.2 or even a later version of Processing depending on when you're watching. I am on macOS. I am using an Intel. It's an older Mac. 

So if you have an M1 or an M2 Mac, you'll want to click on the Apple Silicon version instead. And then also here, if it's not auto-detecting properly, you could go to Windows to grab the Windows version, Linux, and-- ooh, there's even a Raspberry Pi version of Processing, which could be something you want to try someday. So I'm just going to click right on here. It's finished downloading. 

I'm going to unzip, and I have the Processing application there. So I can actually just double-click and run it. Or maybe on a Mac, I might want to go to my Applications and actually move it in there. 

And then once it's in there-- and you can see I have some other versions of Processing that I'm keeping there. I could double-click it. And it's asking me to make sure I want to open it, which I do. And there we go. There's Processing. 

I'm going to show you very quickly a screen capture of the same thing happening on Windows. And also, in case you're curious, this is what it looks like on Linux. And if you have any trouble downloading and running Processing, there's places you can ask for help-- the comments here, the Coding Train Discord, and the Processing official forum as well, all of which I will link in this video's reference materials. 

[MUSIC PLAYING] 

It's time to start talking about coding. Any moment now, we're going to get to writing code. But because this series is about learning to code through the lens of drawing images and animations, I need to start first by talking about pixels and a computer graphics window. 

This is a rather poor drawing of any window that you might open on your computer. Maybe it's a browser or some game. And in fact, Processing-- the programs you write in Processing, the code will generate a window like this that you get to draw into. 

So the first thing that you need to think about is the dimensions of this window. And what do I even mean by that? Let's start by drawing something that looks like this. 

Maybe one day in your life, many years ago-- maybe just yesterday-- who knows-- you took some kind of math course, where you talked about a Cartesian plane. Named for the mathematician Rene Descartes, a Cartesian plane is a flat two-dimensional space with two axes-- an x-axis and a y-axis. The center of the plane is known as the origin, or the point 0, comma, 0. An x of 0 and a y of 0. 

If I were to mark any given point in this plane, like this one, I could specify the location of that mark by its x-coordinate and its y-coordinate. So this is actually the point 5, comma, 6. 0, 1, 2, 3, 4, 5. 

0, 1, 2, 3, 4, 5, 6. The x is 5, the y is 6. So there's units of measurements, there's the space that we're defining. But the key thing to note here is there are no, quote, unquote, real world measurements. Instead, the measurements are in pixels. 

So the question for you to ask yourself right now is, if I were to draw a dot in the center of this window, what is the x-coordinate and the y-coordinate of that dot? You might be thinking to yourself, oh, I know where you're going with this. 

Look how, in the center of this, the origin is 0 and 0, and you just drew that dot in the center. That must be 0, 0. And in some systems, it could be. But a standard rectangular computer graphics canvas-- one that is in two dimensions-- the origin is typically in the top-left. 

That's where 0, 0 is. Other thing that's a little bit odd about a computer graphics window is that here, in the Cartesian plane, I could easily draw a point right over here, which would be something like negative 6 for the x, positive 1 for the y. There are negative spaces along the x and y-axis relative to the origin point. 

In a computer graphics window, while the x-axis is the horizontal axis, and the vertical axis is the y-axis, positive numbers point down. It is essentially flipped from the Cartesian plane. And that means there are no negative pixels within the canvas itself. 

Now, there will be a time where you want to expand quite a bit beyond this. There are 3D renderers. There are all sorts of ways of transforming the space that you're drawing into. But at its core, when you first begin, there is a canvas where the units of measurement are pixels. 

0, 0 is the top-left. We count to the right for x and count down for y. So I return, again, to the question of, what is the x and y-coordinate of this particular pixel? Almost all the way there to answering this question. 

We need one more very important piece of information, which is what is the width and height of this particular window. There is no answer to that. It's whatever you happen to define it to be. Most of the Processing examples, if you just open them up, you'll see that they come with a predetermined width of 640 and a predetermined height of 360, which would mean if this is in the middle, the x location is half of 640, the y location is half of 360. 

Let's all say it together now. The xy location for that point is 320, comma, 180. I don't know why I drew the line like that, but there it is. Guess what? It's time. 

I think we can write the very first line of code that I'm going to write in this entire series. And maybe-- just maybe-- this might be the very first line of code that you write in your entire life. Oh, this is a momentous occasion. Let's all just soak it in and savor it for a moment. 

Assuming you've been following this whole series so far, you've already downloaded Processing. As of the time of this recording, I'm using the most recent version of Processing 4. It's showing me a wonderful welcome message, where I could click through and look at some different examples, which I would encourage you to do. 

But I am going to uncheck show this message on startup and click Get Started. I'm just going to move my window around for a little bit. There's quite a bit more that I should probably say about the Processing environment itself-- how to save your code and organize your files. You can change the colors, and the font, and all of that stuff. I'll try to come back to that at some point in this series. 

Hi, Dan from the future here. Sorry to interrupt. You might be wondering why your Processing window is a lovely blue and mine is this glorious pink sunset color scheme. Well, there happens to be a theme selector built into Processing. I forgot to show it to you. 

It's under Tools, Theme Selector. And there, you can change to whatever color scheme strikes your fancy. But I don't even want to worry about that right now. I just want to write that first line of code. 

And there it is. Size, open parentheses, 640, comma, 360, closed parentheses, semicolon. My program is called kneaded tapioca. To run the code, all I have to do is press this Play button here. 

And there we have it-- a window of size 640 by 360. Just to see that this is really working, what happens if I were to change this to 960? Now, I have a much taller window. I should also note just right now-- I don't know why I'm showing this to you now-- it should come back to it later. But instead of writing size, I could just write fullScreen, and run it again. And whoa! Now, I have a full screen Processing window, but that's a bit of an aside. 

Now, if you're wondering how the window just magically appeared there, I'm on a Mac, so I can hit Command-R as a shortcut to run the sketch. I kind of do that just intuitively having done this for 20 years, and I'll be doing that a lot throughout this series rather than clicking the Play button. If you're on Windows, it's Control-R. And then if you're on Linux, I don't know. You tell me in the comments. What's your shortcut? 

Back to this first line of code-- let's unpack it a little bit. There are lots of different kinds of lines of code that I'll be showing you how to write. But this kind of line of code with this format is going to keep us happy for a very long time. This is what is known as a function call. 

For right now, let's put that word function aside and just think of it as a command. What is the command? The command is size. I hereby command you, Processing, to create a window of size-- size what? Size what? I'm waiting for you to finish that command! 

Many commands need to be modified or specified with arguments. It's as if I gave you the command to walk. I could tell you to walk fast, or walk 10 steps, or walk in the Eastern direction. Here, the arguments are the answers to the questions that the computer needs in order to be able to execute this command. 

You're telling me to make a window, but don't know what the width and height is! These are the arguments. Also sometimes called parameters. And there's a kind of distinction between arguments and parameters, but I'll get to that another time. 

So for this first part of you beginning to learn to code, this is all you need to know. Every line of code that you write for now will be a command, or a function-- the name of that function. So I'm going to say name followed by parentheses, open parentheses, closed parentheses, ending with a semicolon. Because Processing, as I mentioned earlier, is based on the Java language, you really are writing Java code with Java syntax. 

The semicolon-- and I drew that in a weird way, but the semicolon indicates end of line. Programming languages have a variety of different syntaxes. Some of them require semicolons, some of them don't. That's for you to explore as you move past this video series. 

For now, every line of code must end with a semicolon. And Processing will give you an error if you forget it. Then you optionally need the arguments. Remember when I showed you that full screen command? It didn't need any arguments, because fullscreen just means go fullscreen. 

I don't care-- I don't need a size-- I'll just do whatever the size of the screen is! But here, I need to have some number of arguments-- 0 or more arguments separated by commas. What are those arguments? For now, again, they're mostly going to be numbers. 

But as you will soon see, there are other kinds of things that can be arguments to a function-- to a command. So here's a question for you now. This is kind of fun because we can play the creators and designers of Processing. 

We are inventing Processing. We've already invented the idea of the size command. Let's say I want to draw this point now in the center of the window. What would you make the name of that command and the arguments for that point? Think about it. 

[MUSIC PLAYING] 

How about point, and then I want the center, which is 320, 180. Let's run that again. Do you see it? Let's look in there. There's that point! 

I have now drawn a single point at the center of the window at pixel x-- 320-- pixel y-- 180. Guess what? What if I wanted to draw a line instead of a point? Well, I could draw a line with the command line. 

What do I need to draw a line? Let's think about it. I need another point. So maybe I need to draw a line. I need to have two pairs of xy. x1, y1, x2, y2. That's the syntax for drawing a line. 

Now, where is that point on the whiteboard? Let's just estimate something interesting, like 520, 100. Look at that beautiful line. So you might be asking yourself a question, which is why is the line black, and why is the window itself gray? 

Well, those are default colors. And certainly, if you're a designer, or if you're anyone really watching this, you probably want to know, how can I change the color? I'm going to get to that. 

But before I get to that, let's just sit here for a moment and think about how we've now learned the commands size, point, and line. There are a lot more of these. For example, if you want to draw a square, there is the command square, there is the command circle, there's a command for rectangle, for ellipse, for triangle. 

Oh, we can make custom shapes like different kinds of polygons. I will be covering more of these. And I'm constantly going to go back and look at different shapes, and I should probably talk about arc at some point, which is a way of drawing part of a circle. 

But the thing is, you're here learning to code. And I hope you're enjoying this, and learning something, and maybe I'm doing a halfway decent job of making this video. But the real skill-- the real thing that you need to practice is not listening to somebody else tell you how to do it, but kind of trial and erroring your way through it, and reading the documentation which covers all the ins and outs of all of these functions, because there are a lot of them. 

And coding is not about memorizing them or just knowing how to do it. It's about figuring out how to look things up and trying it yourself. So let's look at that. 

[MUSIC PLAYING] 

One wonderful thing about Processing is I can highlight any name of a function, right-click or Control-click, and go to Find in Reference. It's going to take me directly to the reference page on the Processing website that explains this code. There's a wonderful paragraph description. 

There are several examples that show the function being used. And here, you see the syntax described. What is the name of the function line, and what are the expected arguments? 

Now, functions of the same name, like line, can take variable amounts of arguments, and this is something that we'll see. Right now, we're not drawing with a 3D renderer, but a line can be drawn in a 3D space, in which case, it needs an x, y, and a z-- something I'll come back to in some other videos some other time. But both of those are covered here. 

Once you see that syntax, it's important to look under the parameters-- again, parameters being another word for arguments. x1 being the x-coordinate of the first point. And importantly there, notice that word float that's in parentheses. That might be a very strange word to you. 

It's actually something that's going to become quite important a little bit down the line. I don't want to get into all the details about what a float is right now, but that is a term for number. I'll also point out that functions can have a return type. We'll be coming back to that later. 

And then this is nice to see-- related functions that I'm not using right now. But for example, stroke weight is a function that allows you to vary the width of the line. Is it a thicker line or a thinner line? And you could look into that yourself. 

Let's click back to the reference home page. And we can now see this is all of the functions that are available in Processing. See what I mean? There's a lot. Oh, look-- size is right down there. There's one we know. 

I could look for one by typing into the filter. But right now, what we are covering are shapes. So I'm going to go here under Shape, and specifically, 2D Primitives. There are lots of different ways to draw in Processing, but if you're just beginning, I recommend that you start only with these 2D primitives. 

Arc, circle, ellipse, line, point, quad, rect, square, triangle. So let's take one that we haven't tried before. How about circle? First thing I can do is I could just copy this code right here and paste it into Processing. 

There's my circle. Now, certainly, I want to scroll down and see what are the arguments and what do they mean, but I could also just play around with the numbers. Like, what if I change 220 to 100? The circle's smaller, so that must have to do with the size of the circle. 

What if I change to 24 to 500? The circle is further to the right. That must be the x location of the circle. And in fact, if I scroll down, we can see the circle function, or as I'm referring to it now, command takes three arguments-- an x location, a y location-- and this is kind of a technical coding term here-- extent. 

Extent is a generic term for size. But as you're going to see with the circle-- if this is my circle at this particular xy location, a way of measuring the size of the circle-- it could be radius. Radius is the distance from the center to the edge of the circle, but Processing is actually using the diameter of the circle. 

So the extent is how wide is the circle? What is the-- a circle is uniform, so the width and the height are the same. Essentially, the arguments for circle are x, y, and diameter. Let's go back to 2D primitives and let's try square. 

Let's take this example square, copy it into our code, run it, and there's that square. Now, interestingly-- let's think about this for a second. Just imagine-- this window is 640 by 360. The circle is at x 500, y 184. 

Let's do something to make things a bit more uniform. Let's put them both at 180, and let's have them both be the same size, only the circle is at pixel 500 and the square is at pixel 100. What-- I'm expecting to see this. 

If this is approximately x pixel 100 and this is approximately x pixel 500, and this is 180, we know the circle appeared here. So I would expect to see the square here. Let's go see what we get. 

Huh? Kind of doesn't look like what I just drew. Instead, it looks like this. Well, every shape has a reference point. For a circle, the reference point is the center of the circle. 

For a square, the reference point is the top-left of the square. If I had just read the documentation page, it would explain that. By default, the first two parameters set the location of the upper-left corner. The third sets the width and height. 

The way these parameters are interpreted, however, may be changed with the rectMode function. Scrolling down, we can see, yes, the syntax for the square is x, comma, y, comma, extent. And related-- rect for rectangle and rectMode. There's a lot of information about all the possible ways you could draw a square or rectangle, but I just want to talk about corner versus center. 

And the default mode that we just drew is corner, because the reference point is the top-left corner. But if I want the reference point to be the center, all I need to do is change the rectMode to rectMode center. I want to put this line of code before I draw the square, and the order is really important. I'm going to get to that in a moment. 

And now, we can see I have my square centered at 100, comma, 180, and my circle centered at 500, comma, 180. Just for fun, let's put that line between those two connecting them. 100, comma, 180 to 500, comma, 180. And there we go. 

Look at this drawing I made. If you're following along, I think this might be the first drawing you've ever made with code. Congratulations. It's very exciting! 

Let me show you an important detail. I'm going to take this line of code, which draws the line, and I'm going to just change it and place it after drawing the square. Think about what is the difference going to be? The line is now on top. Did you catch that? 

Processing is following the lines of code you are writing in order and layering the shapes on top of each other. Now, there is such a thing as transparency, and color, and I'm going to get into all of that. But that's a very important detail for you to explore right now. 

If I want to design a particular pattern, what needs to come first, and what needs to come second, what needs to come last in order for me to execute that particular pattern? So this is a great stopping point for now. My assignment to you-- this video is going to keep going, so you can just keep watching, if you want. 

But you could pause right now and create your own design. Maybe make a self-portrait, a little alien, some kind of spaceship, some kind of abstract design, a flower perhaps. Can you design something only with lines, points, circles, and squares? 

Or maybe you're feeling a little ambitious. Do you want to try one of these other shapes that is listed under 2D primitives? A rectangle for example, is just like the square, only we have an extra argument. Instead of one argument for the width and height, we have an argument for the width and the height separately. 

A triangle is 3 points. A quad is 4 points. Probably the most difficult one on here is arc, so I'll come back to that at a separate point to look at it specifically, but see what you can create. 

[MUSIC PLAYING] 

Here's my version of the assignment. It's a character named Zoog that I created for the learning Processing book, which this video series mostly matches. Looking at this, I realize there's a couple of things that I really should mention here. 

Number one is, you're going to want to save your code. So here is the code that I wrote while I was going through this tutorial. If I were to go to File, Save, it's going to pop open with a prompt for me to save my sketch. 

Every sketch has a name and is saved into a folder on your computer. So I'm going to call this CodingTrainExample1. And maybe I want to think of a better naming convention, but for now, I'm going to call it that. And I'm going to hit Save. 

If I go to File, Sketchbook, you can now see Processing has its own window that's showing me all the sketches I've saved to my Sketchbook-- Zoog, which I already had preloaded in there, and CodingTrainExample1. If I were to click on it and say show folder, it's going to take me to the Sketchbook folder itself. 

There, you're going to see a lot of extra stuff because things like different libraries you might use-- we'll get into that later-- examples that are there, there's modes, there's tools. All sorts of stuff that we don't need to worry about right now. But if I go and look in the Zoog directory or the CodingTrainExample1, you'll see a file with the PDE extension. That is a raw text file with your code stored in it. How you want to manage, more broadly, the file system on your computer, that's for you to sort out. Easiest way to work with Processing is just to use the default sketch folder. 

[MUSIC PLAYING] 

And you'll also notice something else in here-- body, head, eyes, legs. That doesn't look like code. It doesn't follow this syntax that we've described, and in fact, it's kind of grayed out. 

Well, these slashes at the beginning of this line of code that says head indicate to Processing that this is a code comment. A comment is a note to self-- something you're writing in there to annotate what you've been working on that's for Processing to ignore as it's executing the code itself. This is incredibly useful, and I highly encourage you to overdo it right now and put comments all throughout your code. 

It'll give you a nice habit for later. This is really good if you're teaching, because you can put explanations in there. But it's even good if you're the only person ever working on this piece of code, because you might take a break from it, you might come back to it. 

You might say like, oh, todo-- let's add some hair. So I can add a little note to self or something I want to do later. Code comments can be anywhere you want with anything in there. They've just got to be all in one line, because if I try to continue that comment onto the next line without a slash, slash, and run the sketch, it's giving me a syntax error. 

[MUSIC PLAYING] 

Processing has kind of got it wrong. This isn't a missing semicolon. This is like, you forgot to add the slash, slash, for the comment. So let me put that in. 

Let's take out the semicolon here and run it. Ah, now we really are missing a semicolon. Weirdly, it highlighted the line below, because even though the semicolon is missing from here, it discovered it as it got to the next line, and there was no semicolon before telling it to stop. 

So this is what I want to emphasize to you. When you have a mistake in your code, an error message will pop up below in the console. But very often, that error message will be misleading because it's just doing its best job trying to guess what your intentions were. 

Processing is actually pretty good and has a bunch of friendly error messages in it. I'd be curious-- so you can add into the comments of this video of what error messages are you finding that I haven't covered? This is probably also a good time for me to remind you that you can join the Coding Train Discord, where you can post form messages to ask for help. And of course, there's also an official Processing forum, where you can also ask your questions as well. 

Let's try to see if we can get one more error. Let's leave out the diameter parameter for circle. Run the code. And here we go. This is a great error message. 

The method circle, float, float, float in the type PApplet-- oh, my goodness. What's PApplet? Well, PApplet is sort of a fancy name for your sketch as a whole. We could get into why that is, but that's going to send us off on way too many tangents. 

Is not applicable for the arguments int, int. Wait. But I put in two numbers. That should be float, float. Oh, data types! 

We're coming. We're going to get two data types-- what's an integer versus a floating point number. But we can see here that this error message is telling us we're missing a particular argument. We're missing that last argument for the diameter of the circle. I fixed the errors, took out those extra comments. 

There's Zoog. Take some time to try your own. And when I come back, I'm going to look at adding color to this sketch. 

[MUSIC PLAYING] 

How did that go? How did your drawing turn out? I'd really like to know. In the video description, I'll add some information about how you can share that with me, if you feel so inclined. 

But now, it's time to make our world a bit more colorful. If you've watched any of my videos before, you know I love a good rainbow. So now is the time to make everything rainbow-themed, if we can. 

So before, we were looking at the syntax for issuing a command, or a function call, and I made a list of some of the 2D primitive shapes. You could draw let me now make a quick list of the commands that you could use to specify colors-- background, stroke, fill. So here are three to start-- background, stroke, fill. 

There are more, but these are the three sort of core basic ones, and each one sets a color for a different aspect of what we're drawing in the Processing window, and I'll be getting to the details of that in a moment. But all of them require arguments that specify what color it is we want to set. 

So how do we define color as an argument? Can it be a number? Yes! The simplest way to start with color is to define color as a shade of gray or gray scale. 

A gray scale color value is defined as a number with a range from 0 to 255, and I'll get into why that's the range in a little bit. 0 is the value for black. 255 is the value for white. And everything in between is some shade of gray, so maybe 127 is a medium gray. 

It's useful, I think, to think of this as a dimmable light. If you turn the light all the way off, total darkness. All the way up-- bright white light. For any of these functions, if I were to put just a single number inside the parentheses as its argument, it's going to set the color to its corresponding grayscale value. Let's look at that in practice. 

Circling back to this example that I've been building, let's add the function background. I'm going to put it right after size. And again, I'll come back to the order in a moment. A background of 0 fills the entire canvas with black. 255 fills it with white. 

So background is the function to place a color over the entire canvas of the Processing window. Stroke is a function that sets the outline color of any shape. So in the case of a rectangle, stroke sets the outline. Fill is a function that sets the interior color. Now, let's try to change the color of the circle. 

So I can give it a stroke of 127. Let's give it some gray value and maybe a fill of 0. Let's see what that looks like. I could zoom way in on that circle, and I could see that there is a gray outline there. But this is probably a useful moment for me to let you know about an important function to modify the thickness of the outline of shapes or the thickness of a line color, and that is stroke weight. 

[MUSIC PLAYING] 

I'm going to write it down here because it's technically not a function that assigns color, but it is quite tied to the color functions. By default, the thickness of any line that you draw in Processing is one pixel. So if you want it to be more than one pixel, that's where stroke weight comes in. 

So it's probably more visible to you now-- the fact that the line is gray and it's a bit thicker. But wait a second! What's going on? The rectangle also has a fill that's black, and a gray outline that's thick, and the line is thick, and gray. 

Order of your code is very important. Any time you call any of these functions, it's as if Processing picked up the pen-- the pen with a certain color-- I mean, this one's purple-- and of a certain thickness. It's going to keep drawing with that forever until you tell it to switch to something else. 

For example, if I were to take all of these lines of code and now place them above the square, you can see that the square is black with a gray outline. And the line that I'm drawing after the square is also thick and gray, but the circle has a thin black outline and a white interior. That's because I drew the circle without specifying, so it used the defaults, and then picked up that new pen for everything that came after it. 

So if I want the circle and the square to look different-- to have their own stroke and fill-- I just need to add the write function calls before each of them. Make a stroke weight of 8, a stroke of 0, and a fill of 51. Let's make that Phil 175 so that we can see it more clearly. 

Now, we can really see the distinct stroke and fill of each one of those shapes. And I can also be specific for the line. I'm going to say a stroke weight of 1 and a stroke of 0. There we go. 

This is all well and good, but you're not here just to make grayscale designs. although, there's something kind of nice about that. You're here for the full rainbow of glorious, wonderful color. 

[MUSIC PLAYING] 

As I will get to, there are plenty of ways to specify the full range of possibilities of color in Processing. But the core, the foundational, the basic starting point for you and me right now at this moment is referred to as RGB color. Unlike grayscale, which just has one value, RGB color is indicated by 3 numbers-- 1, 2, 3. 

R-G-B, or Red, Green, Blue. I talked about the Cartesian plane as something you might have done a while back or currently in school. Something you might have also studied or tried at some point maybe when you were really little is like finger paints, and their primary colors, and you can mix them, and you could get different colors out of mixing the primary colors. It's been a while since I used actual finger paints, but this is all operating under the same principle. 

The idea is that with some amount of red, some amount of green, and some amount of blue, I can create any color of the rainbow. But the key concept here is this is not like mixing paint. This is like mixing light-- as if I had a red flashlight, a green flashlight, and a blue flashlight, and was turning them up and down, and on and off, and shining them on various surfaces. 

Each one has a range from 0 to 255. And again, put a pin in it. I've got to come back to why is this the range again and how do I change that if I don't like that range. It's coming. 

So let's think about this. If I wanted pure red, I would put the red dial all the way up to 255, and the green dial down to 0, and the blue dial down to 0. In practice, that means I'm going to give three arguments to the function background-- or stroke or fill-- the first one being 255, second being 0, and the third being 0. 

Look at that-- red background. Now, what's your favorite color? Mine is purple. So I think I could get a purple by adding some more blue. Let's give it 150, and a little more than halfway, a blue. Hmm, that's a lovely purplish tint there. 

[DING] 

I'm going to make up some numbers to put in the various strokes and fills so we can see that as well. Look at my design. Actually, I'm quite pleased with that. Guess that's more of a pink than a purple, but close enough. 

I want to talk about a few more details related to color, the range, how I would adjust the range. But before I do that, this is probably a good time for you to just pause and see if you can add different RGB colors to the design you made previously. Take your time. I'll still be here. Actually, I'm just going to keep going, but you'll have to pause the video. 

[KEYBOARD TYPING] 

How did that go? If you have questions, again, leave them in the comments or the various places that you'll see in the video description where you can get additional help. 

[MUSIC PLAYING] 

Before I move on, let's unpack this a little bit more. I'm imagining that this seems kind of odd to you-- like, why 255? Well, one thing you might have to realize here is if we're counting all of the possible numbers from 0 to 255, the total possible amount of numbers is actually 256. 

I know this is like, what are you talking about right now? This is actually really important, because this is going to come back again and again in various things we do with code. Think about it. If the range of numbers is between 0 and 4-- and I'm talking about whole numbers, so obviously, there's the distinction there-- there are five whole numbers. 

0, 1, 2, 3, 4-- that's five numbers. 256 might seem like an odd number, but it's actually kind of-- well, it's an even number. But it might seem like a strange choice, but it's a pretty important number. Let me show you why. 

Let's start with the number 2. Let's double that number and make it 4. Let's keep going. And we've got 8, then we've got 16, 32, 64, 128, 2-- oh, 256! 

It is a power of 2. This might be something you're unfamiliar with depending on where you are in your life's journey around mathematics. But a power of 2 is any number that you can get starting with 2 and multiplying itself by 2, and 2 again, and 2 again, and 2 again. 

This is actually 2 to the 8th power. Why is that number 2 important? Now, you might be familiar with the idea of binary numbers. This code that we're writing is all this kind of high level language written with some words in English-- some strange syntax. 

But it's all a mechanism for us to be able to write the instructions in a language that feels somewhat more human-like than machine language, because the language of computers is just 0's and 1's. A single bit-- one little on/off switch inside the brain of the computer is a number, 0 or 1. 

The sun is coming in, by the way. Did you notice that? There are two possibilities. So if I were to have two bits, I have four possible ways I can configure two 0's or 1's. If I have three bits, I have 8 possible ways. 

If I have 4 bits, I have 16 possible ways. Well, it turns out that we are going to store color values in 8 bits of the computer, or 1 byte. There's 1 byte in memory of the computer in its brain, where it can describe the red, or it can describe the green, and where it can describe the blue. So this is why you have that range. 

[MUSIC PLAYING] 

We are so far removed from the low level machine language in Processing that this is something that we can alter if we don't want to think about it this way. If we prefer to think of the red value as a number between 0 or 100, we can-- like 0% to 100%. We can. 

In fact, we don't even have to only think of color as RGB. There are other ways to define color. Another system for defining color is known as hue, saturation, brightness. 

This is a bit beyond where I want to get right now. I will put in the video description a link to the online book, Programming Design Systems by Rune Madsen, which has a wonderful chapter about color. It goes into HSB, or sometimes called HSV color, in more detail. But for our purposes, the function that I really want to make sure to add here, where you can alter and customize how it is that you define color, is called color mode. 

And I realize I forgot two other functions that I need to add to this list, but let's go back and look at color mode for a second. Color mode changes the way Processing interprets color data. Again, I don't want to get too far into this. 

This is something that I think will prove more useful later. And a lot of the examples here are using code concepts that I haven't covered yet. But if you're really interested in how color is defined and can be customized, I would certainly encourage you to read through this in more detail. 

Here's a really nice version of this that I think we could use right now just to see how this works. If I were to call color mode and set it to RGB 1.0, this means that the range of color is now no longer between 0 and 255, but between 0 and 1. So 0.5, or 1/2 essentially, would be like 50% red, for example. 

To make this a little more understandable, let me adjust this a little bit and change it to 100. What this means is the range is now between 0 and 100 for every color value. Of course, it's doing weird things because I've written numbers that are bigger than 100. 

So it's going to just like consider those as maxed out, but you can see that already the colors changed. Just for background, I can change this to 100, 0, 50, and this would be full red, no green, and half blue. 

[MUSIC PLAYING] 

So let's put color mode aside now. There's a really important thing that I've neglected to mention, and let's get to that right now. Transparency, otherwise known as alpha. You could also think of it as opacity. 

Something being fully opaque means you can't see through it. Something being fully transparent means you can see completely through it, almost as if it isn't there at all. In fact, I can essentially modify this idea of RGB color and call it RGBA color for Red, Green, Blue, Alpha. 

So this is adding yet another bite to the way we define a particular color. Alpha, also having a range between 0 and 255, again, by default. The reason why I mentioned color mode is I actually often like to change this to between 0 and 100, because it's useful to think of transparency, for me, between 0% and 100%. 

Let's see what this becomes in practice. Now, it doesn't make sense at the moment for the background to have any transparency. This is something we could come to again later. But what if I want the square, for example, to be slightly transparent? 

The fill of this square is currently a nice yellow-- full red, full green, no blue. Let's add a fourth argument for transparency, and let's give that value 150. Remember, the full range is between 0 and 255, so that's just a little bit transparent. 

Hmm, it looks kind of orange now. Why is that? Well, it's mixed, essentially, with the pink that's behind it. To make this a little bit more clear, let me remove this line. I'm going to move that scroll all the way over to pixel 400, and let's make the circle a little bit bigger as well. 

Look at that. We can now see how the square is transparent. It's blending with whatever color is behind it. And again, to be clear only the fill is blending. The outline is not transparent. 

The default value would be 255-- fully opaque for any shape. Let's make it even more transparent-- set that value to 50. Now, there's barely any color there from the square. 

Put it back to 200-- make it more opaque. And there, we can see. So again, this is something you can really play with. The relative transparency of different shapes, and how you place them will create all sorts of different designs. 

The order, of course, is again very important. I think it's also important for me to say here-- and maybe this is obvious to you-- that it's not actually transparent. This is still just a flat screen, and each pixel just has one color. But Processing, the rendering engine behind the scenes, is saying, you have this yellow color, it's on top of this blue color, this one is transparent. I'm going to do some math to blend those colors together. 

And this is something I could also get into more. There is something called a blend mode, and there are different ways to blend color. But the default way is just by essentially averaging the colors together. And they're only averaged if I took 50% of one or 50% of the other, but that's essentially the math. Let me take 75% of this color, 10% of this color depending on the relative transparency levels. 

Oh, I'm almost done with color, but I realize two more functions I really want to mention before I move on. Whiteboard is getting to be a bit of a mess here, but let's add them in-- no stroke, no fill. Now, the reason why I just thought of them is because I can essentially create no fill by setting the transparency to 0-- setting the alpha, that is, to 0. 

That is no fill. If it's fully transparent-- 0% opaque-- there's nothing there. I just see what's behind it. But it's rather silly, or inconvenient, to write it this way when instead I could just say no fill. 

So fill 0, remember, is not no fill. That's black. That's putting the fill of black. No fill means fully transparent. For example, for the stroke-- for the circle, I can also say no stroke. 

So now, I've got a circle that's fully opaque with no stroke, and I've got a square with no fill that has a stroke. As with everything that I'm going to be doing, there's so many more ways we could expand on this stuff, but this is a good foundation to start with about color. 

I have taken my Zoog drawing, added some RGB color, some transparency. I even threw in a color mode there to change the alpha range between 0 and 100. Why don't you try doing that now with your own design? 

Give that a try. Maybe take a break for a little while, come back, guess what we're going to do next. This drawing-- this Zoog character, it's static. Nothing about anything I've done here animates or changes as the program runs. This is what I would like to tackle next. 

[MUSIC PLAYING] 

And we are back and ready for the next step. Did you take a break? If you didn't take a break, maybe just get up, stretch, move your body around, if you can. Take a little break for yourself, because speaking of moving your body around, I have something to say. 

This is pretty exciting. You've drawn with code, you've added color, you have some kind of design that I am just picturing as just beautiful and wonderful in my head, but it doesn't move. We'd love to see Zoog do a little dance, bounce off the edges of the window. All of that is possible. 

But we're missing a key fundamental concept here, a concept that I will refer to as the flow of the program-- the Processing flow. If you open up a website, you're clicking around, interacting with things, things change. 

A game-- it starts. The score is 0. You press some buttons, you move around, you increase your score. Programs happen over time. They run over time. 

This drawing of Zoog is essentially a static program. It executes one thing-- this single drawing-- and stops. How can I create a Processing sketch that runs over time, where things change over time based on interactions or some kind of algorithm? In Processing, the flow of a program, at its core, is defined by two fundamental concepts. Welcome to your two new best friends, setup and draw. 

[MUSIC PLAYING] 

Let's think about them this way. Let's say you're designing a game. When the game begins, a lot of things must be initialized. Maybe you start with a score of 0. You have three lives your health is at 100. The level is level 1. 

Those are all the things that happen once at the initialization point of the game. That is setup. Then there are other things that happen. If the game is Space Invaders, for example, there's a lot of things that happen over time. The spaceship moves around and flies, the aliens come in, this-- you increase your score, you lose your lives. 

All of that happens over and over again over time forever, essentially, until you quit the program. That is draw. Setup is initialization. It's things that happen just once. Draw is things that happen over and over again forever. 

The forever, of course, being in quotes, although it would be an interesting challenge to see if we could get a Processing sketch to run forever. These are two fundamental concepts that we need to introduce to our Processing sketch. And the way that I am going to bring these into the sketch is with something known as a block of code. 

A block of code is a organized collection of lines of code that sit in between two curly brackets. It's going to be hard for me to draw these, but I'm going to do my best. We have an open curly bracket, and a closed curly bracket, and some number of lines of code in between those two curly brackets. 

So we are going to define the setup block with curly brackets and the draw block with curly brackets. If you're following along, you could expand on whatever design you created so far, but I might suggest right now you start over, or at least heavily simplify that particular design. I've taken my example and taken out the line and the rectangle-- just simplified the color. And now, I have just one single circle appearing in the center of the canvas. I am now going to add the setup and draw blocks of code to this example. 

I have typed in quite a bit of new, strange, unfamiliar syntax, which unfortunately is going to feel kind of wonky and weird and uncomfortable for you for a little while still. Don't worry. By the time this video ends, however long it is, I will have covered all the ins and outs of everything I just typed in there. 

But for now, I want you to focus on two things. I want you to focus on the keywords set up and draw-- they're bolded there by Processing-- and the open and closed curly brackets associated with those. It's the setup block and the draw block. Notice also how the lines of code that are inside those curly brackets are indented. 

I typed that all in kind of quickly, so you might have missed how did they get indented. Well, I could have manually done that with Spaces or Tabs. Oh, boy-- Spaces or Tabs. 

But actually, what I did is use one of my absolute favorite things in the world of coding and Processing. It's right up here under Edit, and it's Auto Format. Command, or on Windows, probably Control-T. 

But this is the key thing I want you to focus on-- setup and draw-- open curly bracket and closed curly bracket. Blocks of code. It might seem like I'm overemphasizing this, but this concept of a block of code is going to extend to so many things that I show you throughout all of these fundamental building blocks of programming the computer in Processing. 

So if the flow is defined by setup happening once and draw happening over and over again-- forever, if you will-- what kinds of lines of code should go in the block of code that is setup versus the block of code that is draw? In this case, I'm programming just a simple design, so there's not a lot of options. But let's consider first the line of code size. Well, certainly, size is an initialization condition for my Processing sketch. 

It's a thing that's defined at the beginning. It's not something that I'm defining over and over again. So size should go here. Background is a really interesting question. 

Should it go? Is it something that I define at the beginning-- the background of the sketch, or is it something that I define over and over again in draw? Think about that. There's no right answer to this. 

For right now, I've placed background in Setup, which is a little bit odd, but let's go with it. Let's go with it. Usually, I do it the other way around when I'm demonstrating this, but let's see where this leads us. 

Draw is named draw. Even though it's a loop-- a forever loop-- it's named draw because it's typically where you will draw the stuff. Again, for any design that you're animating, you've got to draw it, move stuff, draw it again, move it, draw it again. 

We haven't gotten to the moving thing, but we are-- we have gotten to the drawing thing. So maybe in this case, we've got a call to fill, we've got a call to circle, et cetera. So this is what we've got. We now have a program that runs forever over time. 

Let's get even more detailed about this for a moment. What's actually happening? Remember, Processing executes the lines of code in order. It was very simple for us to follow that order when it was just a linear list of lines of code. 

Now, we have these two blocks, but I'm going to talk you through it. The first thing that happens is size. The next thing that happens is background, then set noStroke, set a pink fill, draw a circle. 

What happens next? Draw loops back to the first line of code. So we set noStroke, we set a pink fill, we draw the circle. A noStroke, fill, circle, noStroke, fill, circle, noStroke, fill, circle, noStroke, fill, circle. This is what's happening. 

But because nothing ever changes-- noStroke, fill, and circle are executed with the same arguments every single time-- we never see anything different, and visually, it appears static to us. What we need for it to animate-- for it to change is to introduce variability into our sketch. Now, at some point, in a moment, I'm going to erase this whole whiteboard, I'm going to write variables across the top, and we're going to unpack all sorts of details about how you define variables, and use variables, and all of that. But a quick little entry point-- we're just going to dip our toe into the variable water here-- is to use something that is known as a built-in variable in Processing. 

[MUSIC PLAYING] 

Processing comes with a whole bunch of these, and they're quite fun, and quick, and easy to use. Two variables that are really going to just explode the possibility space of what we can do even right now are mouseX and mouseY. So I'm going to write variables. I've got a little bubble here, and these are two variables that we're going to get to use. Right now, we can use them anywhere we want in our code, but they're going to make the most impact if we use them in combination with the circle command inside the draw loop. 

Where am I going with this? Let's think about it. Wouldn't it be nice if I could just say, hey, you're about to draw this circle-- instead of saying draw it at pixel 320, draw it at whatever pixel wherever the mouse is. Whatever pixel wherever the mouse is. 

Now, of course, if I run that, it's going to tell me crazy syntax error. It can't figure out what the heck I'm talking about. That is not code. That might be something I like to write as a comment. 

And the way to do that within the function itself is to actually use the built-in variable mouseX. mouseX is a stand in for whatever value is stored somewhere in the computer's brain-- essentially, the right word for that is memory. It's keeping track of where your mouse is. 

We can gain access to that value through the reference name mouseX. And Processing, behind the scenes, has defined and set that up all for us. Let's run this sketch now. 

Oh, whoa! What is going on? So first of all, I'm just smearing this circle across the window. Let's get a-- let's try to do a bit more here. At the mouseX and mouseY position, let's add mouseY. 

Let me also make it a little bit smaller-- just 50 pixels in diameter. Look at that. I have a painting program. Think about this. 

Wait a sec. Why is it smearing the circle? To answer that, let's go back to how we divided up the code. Why do I see the previous circle? 

Well, let's follow this again. Size, background, fill, circle, fill, circle, fill, circle. Size, fill the background, draw a circle, draw a circle, draw a circle, draw a circle. 

I never said erase the previous circle. The computer is always going to literally follow exactly what you say to do. So I would need to-- if I want to see the illusion of it moving, I would need to disappear that circle before I draw the next one. 

Is there like erase circle, or should I draw the circle the same color as the background? Guess what? I could try to do goofy things like that, but this is exactly why this placement of background is so critical. If I were to move background into draw, what that says is, draw the background, draw the circle, draw the background, draw the circle. 

And look at that. Now, I have this circle that moves perfectly with the mouse. But this opens up another kind of weird question, at least in my mind, that I really wondered when I was first working with Processing many years ago. 

If it's drawing the background, and then the circle, and then the background, and then the circle, shouldn't I see this flicker, like background, circle, background, circle? Well, the answer to that is, no, because we're not seeing it, but also yes. If that is exactly what we were doing here, we would see that flickering. 

But Processing knows the draw block of code is very special. It's actually doing all the steps off screen in its brain-- in its memory. And at the end draw, it then updates the display. This is referred to as double-buffered animation, because the next frame, if you will, is being rendered in a separate buffer off screen, and only when it's done it gets displayed. 

Then we render the next and display it. So again, I'm getting a little in the weeds of the lower level mechanisms of the computer, but it is an important detail to understand. And this is going to come up as you do more things within the draw loop itself-- that it only updates when it gets to the end. 

I've now defined the flow of the program. Let me move background back into setup. What would happen, do you think, if I add some alpha transparency to the circle? Let's actually make it very light. Like, I'm going to just give it an alpha of 25. 

Look at that. If it sits in place, it's rendering that circle over and over on top of itself, blending with itself, which thickens the color. But as I move it, it's a very slight fuzzy color. 

So even with just this one simple addition, we've created this really fun, quite dynamic, drawing program. There's so few lines of code here. Maybe this might be a good moment for you to pause and play around and make your own version of this. 

[KEYBOARD TYPING] 

How did that go? I don't know. You're probably just still watching the video. That's fine. 

That's fine too. I leave it up to you. I think there are some other really important aspects to the flow of a program for me to discuss before we move on and really unpack all there is to know about variables. 

[MUSIC PLAYING] 

I said that the Processing sketch is organized into two blocks of code-- setup, which happens once-- draw, which happens over and over again. But there are other things that could happen. 

Specifically, there are events that could happen. Let's talk about a certain kind of event. What about if you were to click the mouse? So I am now adding to my list three different blocks of code. 

A setup block-- initialize the program. A draw block-- just do it always. Whenever you can, you should be doing draw. 

Mousepressed is what I would call an event. This is something that's just sitting and waiting. It might never ever run. If a mouse is clicked in the forest, does anyone run the mousepressed code? 

I don't think that's how that goes. But this is the idea. This is code that's just sitting there and waiting. If the event is triggered by, in this case, the user-- the person-- who's clicking the mouse, run that code. 

So maybe something that we could try is what if background gets moved into mouse pressed? Let me add one more block of code. mousePressed-- again, what is void? Why are there parentheses there? Let's get to that later. 

For now, focus on the name of the block of code, mousePressed, and the open and closed curly brackets, which define the block of code itself. And any lines of code that are inside there will be executed whenever you click the mouse. 

Background, 0. So rather than remove background now from setup-- I still want it to draw that background when the program starts-- I just want it to draw it again whenever the mouse is pressed. Making my pattern, clicking the mouse. [INAUDIBLE] D, A, N. 

What fun. I'm writing the letters of my name, clicking the mouse, and erasing it, and drawing some more. Another thing you might be wondering about this-- the order of the code is obviously really important, right? 

Do I draw the circle on top of the square, or the square on top of the circle? Which one comes first-- square or circle? That order that I'm referring to is the order inside of a block of code. 

But these blocks of code-- setup, draw, and mousePressed-- the order that I write them does not define the order that they run. The order that they run is defined by this built-in understanding of the flow of a Processing sketch. So setup could actually be down here, and mousePressed could be up here. 

And this is the identical sketch. Nothing has changed. Processing is always going to look for the block of code called setup, run those lines of code first, then look for the block of code called draw, run those lines of code, then look for the block of code called draw, run those lines of code, so on and so forth. 

And if you ever click the mouse, it's going to skip and look for that block of code called mousePressed. So it's important to note that, however, you absolutely want to keep these as separate and make sure your curly brackets are in the right place. If, for example, I removed this curly bracket here and put it down here by accident, then my setup block is actually defined inside of the draw block. I'll hit Auto Format so we can kind of see that indentation. 

Now, this, to me, looks horrifying. I am about to jump out of my skin here. But for you, well, that seems fine. Like, setup is there, draw is there. Who cares? 

But this is actually quite important. These blocks of code need to be stand alone. We will see nested blocks inside of blocks of code. That's going to come up as we get further down this road, but not with setup, draw, and mousePressed. 

Let's just run to see what happens. Yeah, fortunately, it's giving us a syntax error, so it won't really run it. That error is not super helpful, but I can see that this setup block of code needs to be here separately outside of draw. 

Now, here's my challenge to you. mouseX and mouseY are incredibly useful in all sorts of weird and wonderful ways. I have used them here in probably the least interesting way. It's very intuitive. 

It feels like what I'm supposed to do-- the circle follows the mouse. But mouseX is just a name for a number. mouseY is just a name for a number. I could switch them-- mouseY, mouseX. 

Oh, this is really weird. As I move the mouse left and right, it goes up and down. As I move it up and down, it goes left and right. 

I clicked by accident there, by the way. That's why it cleared. So look at that. This is very hard for me to do. It feels wrong, but Processing doesn't care. It's just going to take the number and use it wherever you use it. 

I could put this back at the center and give mouseX to the red value and mouseY to the blue value. And we can see the color is changing as I move the mouse around, because the value of red is increasing and decreasing. The value of blue is increasing and decreasing. 

Maybe wherever I click the mouse will determine the next background that is drawn. So now, the mouse position determines where the circle is as well as the background color when the mouse is clicked. Let's click the mouse. Whoa! 

Click the mouse, click the mouse. Let's think about this a little bit. I kind of like what I've done here, but what is the range, for example, of mouseX? The range of mouseX is 0 to 640. The range of mouseY is 0 to 360, but the range of color is between 0 and 255. So Processing kind of figures out something to do regardless, but wouldn't it be nice if those ranges matched? 

[GASPS] 

Remember that colorMode I told you about before? The colorMode is something that I could switch while the program is running, but this is another good example of something that very typically would go in setup. I am defining how I'm going to use color over the course of this entire program. 

colorMode. The arguments to colorMode are what kind of color-- in this case, RGB-- then what is the range for red. I want to match it to the width of the window. The range for green-- the height of the window. And then I'm not really using blue here, but let's just leave that as the default. 

Now, when I run this sketch, if my mouse is all the way over to the right and all the way to the top, I should have all red and no green. All the way to the bottom, all the way to the left-- no red, all green. If I'm all the way in the bottom-right, that'll be yellow-- all red, all green. 

Perfect. It's probably pretty rare that I would want to have a different range for red than green and blue. That could get very confusing, but I'm just showing you have a lot of flexibility here. 

This is also a really good moment for me to mention that there are more built in variables in Processing beyond just mouseX and mouseY. Here are two that are also incredibly useful. Width and height-- these numbers, although they stay constant over the course of the sketch, dynamically reference the width and height of your window-- whatever the numbers you originally put into size. 

Simplifying this program for a moment, taking out mousePressed, putting background back in draw, and getting rid of color mode, let's say we want the circle to always be in the center of the window. 320, 180, get rid of the alpha. Now, if I were to change my window size, the circle is no longer in the center. 

It's still at 320, comma, 180 relative to an 800 by 600 canvas. But I can use those variables width and height as well as apply any kind of arithmetic operation-- plus, minus, multiply, divide. And in this case, I want to say half the width, or width divided by 2. 

To do that, I use a slash for divide. Height divided by 2. No matter what size the canvas, the circle is now always in the center. I can also use the same technique to place an object's location relative to the mouse. 

Here, I now have a circle that's mouseX plus 50 and a circle that's mouseX minus 50. The use of these simple mathematical expressions is going to appear constantly throughout all the rest of this video series. Plus, minus, multiply, divide-- these are what are known as arithmetic operators. 

Plus for addition, minus for subtraction, asterisk, or star, for multiply, and slash for division. I have now covered everything I wanted to say. I'm sure I missed a few things about the flow of a Processing sketch. 

I'll leave it to you whether you want to go back to an earlier design that you tried. Maybe you can make a smile into a frown by moving the mouse, or wiggle some antennae of some kind of alien creature you designed around. But I would encourage you to simplify what you're doing. 

In the next section, after you've tried a little bit of code of your own-- hopefully, taking a nice break for yourself-- I am going to cover everything there is to know about variables. Specifically, how do you go beyond using the built-in variables in Processing to defining and creating your own variables? See you there in just a moment. 

[MUSIC PLAYING] 

[SLIDE WHISTLE] 

I'm back. I hope you tried a few things with code. I hope you took a nice break for yourself and are ready to dive in to variables in Processing. Now, we've already been using variables-- mouseX, mouseY, width, and height. But what are those, technically speaking? 

Well, the computer has something called memory. It's a place where it can store information. I talked a little bit about how information, at its lowest level, is encoded as 0's and 1's. 

We don't really need to worry about that here. The point of why I'm bringing this up is when you use the term mouseX in your code, what that actually is is an alias. It's a word that stands in for an address in the computer's memory. 

At that address in the computer's memory is the information you're looking for-- the x position of the mouse. On a technical level, that's what a variable is. It's a word that points to an address in the computer's memory where information is stored. 

It's what lets your sketch keep track of information over time. If you were making a game, you'd need a variable for score, what level you're on, how many lives you have left, all of those things. And here, we see this in action. 

In this sketch, I've got the variable mouseX. Wherever I put that into the code, Processing will then go look in memory, find the location, find that number, and use that where it draws the circle itself. But what if-- and there's another sketch I have running here right above it-- I want that circle to move on its own, and I want it to bounce off the edges as it move around? 

This is a goal I have. At some point, I want to write all the code for this bouncing ball sketch, and this section about variables is the start of that. In order to execute this vision I have, I need to have my own variable-- one that I make up and that I bring to the program, not one that's built-in. 

[MUSIC PLAYING] 

Let's simplify and replace mouseY with just a number, 180. And now, I have a circle that just moves its x position according to the mouse. What if I wanted to make up my own variable? Let's call it circleX. 

If I run the sketch now, I get an error message. circleX cannot be resolved to a variable. If I want to introduce new variables into a Processing sketch, I have to follow three steps. Step number one, declare the variable. 

In order to declare a variable in Processing, I need to specify two things-- the type, or more specifically, the data type-- what is going to be stored inside the variable. And then the name of the variable-- what do I want to call the variable? In this case, it's circleX followed by a semicolon. 

Let's go and add this into the code now. This is a variable declaration-- int circleX. int is the data type. int stands for integer. That's what's going to be stored in the variable. 

An integer is a fancy word for number, or whole number. So 1, 15, 0, negative 3, these are all integers. The name is circleX. Let's list out a bunch of common data types that you might use. 

int for integer-- any whole number, positive or negative. Float is for any number that is a decimal number. So something like 4.31926, that's a floating point number. 

String is a data type for text-- a string of characters. So "rainbow," for example, in quotes, is a string. Text and strings are really important, but in this series, I'm mostly going to focus on using numbers. 

And actually, floating point numbers are the most convenient things to use because it allows any kind of mathematical operations to work. For the time being, we can actually think of let's just use our data type as float for everything. There. I've now declared circleX as a float. 

So what just happened, by the way? When I say float, circleX, semicolon, what happens? Processing tells the computer it needs some space in memory-- however much space it needs to store a floating point number. 

It allocates that space, and then assigns the word circleX to that memory address. So now, mouseX will always pull up whatever data is at a particular address in memory associated with mouseX, and circleX will always pull up whatever value is in memory associated with circleX. But what is there? 

That brings me to the next step. Initialize the variable. I need to give it an initial value to be stored in memory. Coming back to the code, I'm going to do that inside setup. 

This is what is known as an assignment operation. I'm assigning the value 320 to circleX. The variable name equals some data that must match whatever the data type is that I declared the variable as. I can't say circleX equals rainbow, because circleX is a number, not a string. 

Processing, which is built on the programming language Java, is strongly typed. If you're going to make up a variable, you've got to say what you plan to put in that variable, and you've got to stick to it, by golly. Other programming languages are weakly typed, or loosely typed, like JavaScript, and there are pros and cons to each. 

I don't want to get into that right now. We can have a long discussion about that in the comments, if you want. But if you are going to work with Processing, you have to get used to the idea of specifying data types. 

So if I have initialized circleX as having the value 320, that means 320 is now stored in the computer's memory associated with the variable circleX. What is the last? Step use the variable! 

I mean, technically, this is optional. You could declare a variable. You could even skip initializing it, and never use it, and no one would be the wiser. But ultimately, the point of doing this is because you want to use the variable. 

You want to draw this circle at the value circleX. So to get there, you're going to first need to declare it, initialize it, and then it's time to use it. Let's go make sure we have all three pieces of these in our code. 

[MUSIC PLAYING] 

And there you have it. Step one, declare the variable of type float, named circleX. Step two, initialize the variable. Use an assignment operation to say circleX equals 320. 

Step three, use the variable. I'm putting circleX as the first argument to the function call circle to draw the circle at x value 320. Here's a couple more really important details about this. 

Number one, the name of your variable. So there are requirements-- things you can and cannot do in a variable name, and then there are conventions-- things that would work if you put them in the code, but are maybe not what programmers typically do. First thing, requirements. 

Start with a letter. No spaces or special characters other than underscore. And actually, the underscore is also OK as the starting character. circleX is fine, circle_X, _circleX. But you couldn't have a variable called 2circleX. That would not work. 

[DING] 

Now, those are rules. There are also some conventions. Start with a lowercase character. So don't capitalize the first letter of a variable name. 

Capital letters are generally reserved for something that we're going to do later in this course when I start talking about classes and objects. You also might notice here how I capitalize the X, and I just did that instinctively-- circle, capital X. 

The reason why I did that is there is a convention-- it's called camel case-- to-- if your variable name joins multiple words, like rainbowUnicorn, you would capitalize the first letter of the second word. So I'm just going to write here camel case. Some people prefer to use underscores to join multiple words-- rainbow_unicorn. 

The truth of the matter is, everybody has their own personal style and tastes about how to name variables. You'll see how I'm doing it over the course of this video that you're watching. I expect you'll develop your own style-- your own kind of way of naming variables. 

Maybe English isn't your first language, and even though you're kind of stuck using a lot of English words for programming in Processing right now, your variable names don't have to be English words. Another important-- somewhere in between a rule and a convention is don't name your variables other kinds of reserved words in Processing. So I'm just going to write that over here-- avoid reserved words. 

For example, you wouldn't want to name your variable float. Processing will be completely confused and won't work. You probably don't want to name your variable circle or stroke because those are names of functions inside of Processing. 

You can get away with that sometimes, but it's just going to cause confusion, so I would just avoid it at all costs. One more very important detail. I gave you these three steps, and I kind of showed where in the code I put them, but I didn't really talk about why I put them in particular places. 

Let's think about where it is that I am going to declare a variable. The placement of the variable declaration is critical to how you're able to use the variable throughout the course of your sketch. Notice how I put it at the top-- float circleX. 

It's on its own, outside of the blocks of code setup or draw. This is because I want circle x to be a global variable, meaning I want to be able to use circleX anywhere in my code-- in setup, in draw, in mousePressed, and all the future things that you haven't learned yet. 

You can declare variables in other places in the code. I could declare it in setup, or I could declare it in draw, but it then becomes something known as a local variable. We don't have any need for local variables, really, right now, so I'll come back to that when it comes up in future examples that I'm going to write, where they will be needed. 

For now, it's simpler to just say, let me make all my variables global-- let me just list all of the variable declarations at the top of the code. But I'll make a note here-- global versus local-- just to remember to come back to that at some point. Now, where should the variable be initialized? In this case, it makes sense to initialize it in setup. 

This is the initial value of circleX. I want to assign it when the program begins. The code that runs when the program begins is in setup. However, even though I took all this time to talk about declaring the variable and initializing it as two separate steps-- because technically, they are two separate steps, and there are many times where you need to separate those steps-- it's typically much more convenient to do them all in one line of code. 

So if I want to adjust this code and simplify it a bit, I can actually say float circleX equals 320. I can delete this out of setup, and I can say declare and initialize the variable. There-- same exact result. While I'm at it, I should also point out that if I forgot to initialize the variable, and I run this sketch, look at where the circle is. It's at the pixel 0. 

In the case of numbers, Processing will actually assign variables an initial value of 0. But generally speaking, I prefer to explicitly initialize to a specific value even if I want to initialize it at 0, because then there's no confusion. I don't have to question what is the default value for this. 

Now, the last step-- use the variable. Where do you use the variable? Well, if it's a global variable, you can use it anywhere in your code however you want to. And what it is that I want to do right now is I want to see that circle move from left to right. 

That's why I'm here. That's why I made up my own variable. So the value of circleX can vary. This is another way that a variable can be used. We've used it as an argument to a function. Now, I want to use it in an incrementation operation. 

I can take advantage of the fact that draw is looping. Right now, every time through draw, circleX has the value of 0. But what if it has the value of 0 the first time through draw, but then it has the value of 1, and then 2, and then 3, and then 4? 

It'll start to move across the window. How do I do that? circleX equals circleX plus 1. Now, this looks odd. What? Something can't be equal to itself plus 1. 

This kind of incrementation operation, which is another assignment operation-- just like I'm saying circle x is equal to 0, now, what I'm doing is I'm saying circleX should be equal to itself plus 1. Any time I write a statement like this in code, I always evaluate the right side of the equation first. 

So if circleX is 100, I evaluate 100 plus 1. I have 101, and that's what the new value of circleX is equal to. Guess what? Draw loops again-- it's equal to 102. Loops again-- circleX equals 103. 

Let's give this a go. Look at that circle move. What if I wanted to move faster? Well, I could say circleX equals circleX plus 5. 

Now, every time through draw, it's moving 5 pixels. Oh, goodbye, circle. We'll never see you again. Now, in order to have it change direction and move back, I'm going to need a whole other concept that I'm going to be covering later. But for right now, this is a good moment for us to remember that we have the mousePressed event. 

So what I could do potentially is I could reset the value of circleX back to 0 whenever I click the mouse. So now, I'm using the variable in multiple places. I'm using it as an argument to the circle function to draw a circle, I'm using it in an incrementation operation to increase the value of circleX every time through draw, and I'm using it in mousePressed to reset its value. 

Run this sketch. Circles moving to the right. Any time I click the mouse, it goes back to its original position. It's about time to take a break and let you play around with this and maybe try adding a y variable, a size variable, multiple shapes. All sorts of things you could do. 

But inevitably, as you start to do this, things are going to break and not work as expected. And this is one of the big challenges of programming and one of the things that's almost impossible for me to really demonstrate to you, and it's something you have to just kind of struggle through yourself, is how to debug your code. One of the tricks of the trade for figuring stuff out as you're working is using the print or print line command. 

For example, right here in setup, I can say println-- for print line-- Hello! And in fact, in a lot of programming courses and learn-to-code types of environments, if you're working purely with text, this would be the very first program you would write-- print Hello, world. 

But a Hello World in Processing is more like, draw the circle to the screen. But we can get a version of that where now, when I run the sketch, you can see right there in the console the word Hello is printed out. Now, so far, the amount of code we've been writing is very little. 

I've done this multiple times over many years, so I haven't made any mistakes yet. You will no doubt make mistakes. And I, at some point in the course of this whole series, will make mistakes. So I'm going to try to leave those in and show you a little debugging bits as I go. 

But right now, I'm going to have to artificially engineer something. So let's say I hadn't really been paying attention, and I put in 1,000 as the initial value for circleX. And I ran the code, and I don't see the circle at all. 

I'm really just wondering, well, why don't I see the circle? It should be there. I meant to draw it on the canvas. So something that I could do is I could say like, hmm, why don't I look at what the number that's stored inside of circleX is? 

So right at the beginning of draw or at the end of draw-- anywhere, really-- I could say println circleX. This is now going to display the value-- the current value of circleX in the Processing console. I see it down there. 

And this might lead me to realize, aha! Well, that's a really big number. My canvas is only 640 pixels wide. That's why it's not there. Hmm. Oh, I initialized it too high! 

Again, this is something of an artificial scenario that I'm creating, but this is the kind of thing that can happen to you. I would then realize I wanted to start it at 0. So I'm going to fix that to 0, and then ha-ha-- the sketch is working. Again as expected. 

This is a good moment to take a pause. I haven't given you a lot to work with just yet, but I think you could expand on this sketch. Could you add a variable for the y position of the circle? What kinds of mathematical operations-- can you make something fade out by using subtraction rather than addition? 

Maybe the circle grows in size or shrinks in size. It moves from left to right, or up and down. Lots of stuff for you to explore. When I come back in the next section, I'm going to cover a few more details and tips and tricks about working with variables, and look at how you can initialize variables with random numbers. 

[MUSIC PLAYING] 

[WRITING NOISE] 

[CREAKING NOISE] 

[CRASHING NOISE] 

Welcome back. I am about to talk about random numbers, which is very exciting. But before I get there, I just want to look at this statement, circleX equals circleX plus 5 a bit more, and talk about a kind of odd syntax thing that occurs in a lot of Processing examples that you might have already seen, or certainly will see. So this kind of statement, where you're taking a variable and increasing it by some amount-- by 1, by 5, by 10, et cetera-- this is something that is everywhere. 

It's just-- you write it all the time in code. And so anything that's really common in programming-- typically, there are programmers who have figured out a shorthand way of writing it, and this is no exception. A shorthand way of writing this is actually the following. 

circleX plus equals 5. And this means that if I wanted to increase circleX by 1, I could say circleX plus equals 1. So this is take the value of circleX, and set it to itself plus 1. 

Well, this operation is so common by incre-- whenever you want to increment something by one, that there's even a shorthand for the shorthand, which is the following. circleX plus, plus. This might be familiar to you. Maybe you've heard of the programming language C++. 

Well, the reason why it's called C++ is because there was a programming language-- it still is a programming language-- called C. And the next version of it-- the expanded version incremented by 1-- it's a little fancier. It's brand new. 

It's not C. It's C++. And there will come a time even in this series where I start using these shorthands. But generally, for me, for what I'm trying to do in teaching the basics of programming-- and certainly, I think when starting out-- I find this to be a more readable line of code that says exactly what it's doing. 

And finally, I'll also mention that these kinds of shorthand operations also work with multiply, divide, and minus. So I could say circleX minus, minus, which means circleX equals circleX minus 1, or I could say something like circleX divide equal to, which means circleX equals circleX divided by 2. Coming back to the code, just to prove that this is the case, I'm going to change this to plus equal 5 and run it. 

Exact same result. And if I change it to circleX plus, plus, there it is, only it's just increasing by 1 because plus, plus means increase by 1. I'm a little torn about what I'm about to do, but this is also probably a good time for me to just change the variable name circleX to just x, and then say x plus equals 5. 

This is also another personal style thing. What should I name the variable? Well, if I'm going to have a circle and a square, maybe I want to have variables called circleX and squareX to really differentiate them. 

But if I just have one thing, and I only have one thing for which I need one x, maybe calling it x is fine. I could have-- if I had multiple things, I could have an x1 and an x2. There's so many different ways to name your variables. 

And frankly, I could just call this kitten, and I could copy paste it here, and use kitten everywhere, because I love kittens, [MEOWING] and that's what I feel like today. I feel like calling my variables kitten. Probably not a great idea because it doesn't really tell me about anything that I'm actually doing with the code, even though it brings me a little happiness to see the word kitten there. 

But I can't tell you what to do. You [MEOWING] should name variables in a way that makes sense to you that will be helpful to you as you work on the code more. As you take a break from it and come back to it later, think about what is going to have the most meaning for you. And for me, right now, I'm going to go back to x because that's the least amount of typing, and I have one thing, and I want it to be at its x position. That's going to work just great. 

[MEOWING] 

I don't know what you've made so far watching this video, although I certainly would love to know. So check the video description for how you can share stuff with me. But I don't know about you. I'm feeling a little bit like sad. 

Like, all I've got is this circle. And yeah, it's moving. I mean, this is a huge accomplishment, but there's not a lot of possibilities here. Don't worry. I haven't forgotten about figuring out what to do when that circle reaches the edge and have it move back-- bounce off of the edge, if you will. 

But before we get there, I've got something really exciting to show you, which is going to just explode the possibilities of what you can create right now in Processing, and that is the random function. Up until now, we've looked at two different kinds of lines of code that you can write. One, a command, or more precisely, a function call. 

This is anything like background. It's got the name of the command followed by parentheses, and some number of arguments, and a semicolon. Line, stroke, ellipse, circle, all of these are the same. 

We've also now seen, with variables, assignment operations. Here are some examples. We're setting circleX equal to 100, or set circleX equal to the result of some type of mathematical expression. 

There is a way to do both of these in one line of code with certain kinds of function calls. At the moment, every single function call that I've shown you just performs an action. Set the background color, set the fill color, draw a circle, draw a square. 

But some functions actually answer a question. And I think the most wonderful function that we could begin to demonstrate this concept is the function random. The function random in Processing ends with a resulting value. 

It doesn't just perform an action. The action it performs is it picks a random number out of a hat, but it gives you that value back. The function itself evaluates to a random number, meaning we can take the result of the random function and assign it to a variable. 

circleX equals random. Now, random also does require arguments. If we want a random number, we need to specify the minimum value and the maximum value. What is the range of numbers we want? 

So for example, if I wanted a random x position anywhere in the window, I might say the minimum value is 0, and the maximum value is 640. So now, I am both performing an assignment operation. I'm giving a new value to circleX, but I'm also getting that value not from a hardcoded number or a mathematical expression, but rather from the result of a function. 

The technical term for this is that this function returns a value. In fact, it returns a float-- a floating point number. The first thing that we might do with random in a sketch like this is, well, every time it runs, it does the exact same thing. 

But if I added something random, like give me a random x position, now, every time I run the sketch, there, it was kind of in the middle. There, it's all the way to the left. Run it again-- oh, now it's more toward the right! 

But let's make a little bit more dynamic version of this. So I've got a sketch right here that draws a single rectangle in the middle of the canvas. I have two variables-- one for the size of the square, and one for the width of the outline of the square. 

I'm calling that squareSize and lineWidth those are my variable names. How am I doing variable-name-wise? Pretty good, I think. 

So if I were to change squareSize to some random value between 50 and 150 and lineWidth to some random value between, say, 4 and 16, now, every time I run the sketch, I get a different size square and a different thickness for the outline. Demonstrating this by rerunning the sketch over and over again is kind of awkward, so a nice trick I can do is, in mousePressed, I can put these lines of code in there. 

There's something that I've done that's really wrong, though. Remember in our three steps about a variable-- declare a variable, initialize it, use the variable? Well, this is me declaring it, this is me initializing it. 

Here, I'm using it. I do not want to re-declare it. Instead, I just want to use it. So I want to set the value of squareSize and lineWidth to something new. Run the sketch. 

[LAUGHING] 

So something I forgot also, interestingly enough, is background is in setup. Put background in draw. And now, here's what I got. Every time I click the mouse, I get a different square. 

This might seem kind of basic, but if you had designed an entire house, you could actually vary the house randomly every time-- maybe the size of the building, the number of windows, where the door is positioned. These are things that you could do by having more variables, and more calls to random. And I don't have to limit myself to picking the random numbers when I initialize the variable or in mousePressed. I can actually take these lines of code and put them right inside of draw. It's a little jarring how much it's flickering, but what if I add some nice alpha to both the stroke and the fill? 

[LAUGHING] 

Why am I not seeing anything? I have the background in draw. For this effect, where I'm trying to demonstrate the blending of all these random shapes, I need to draw the background just once in setup. 

Just with adding some randomness, we've got a more dynamic pattern and shape. Let's look at another example. Here's an example that just draws one circle in the center of the window. 

First, another shortcut. If I have multiple variables I want to declare that are of the same data type, I don't have to say float x, float y. I can actually say float x, comma, y. And here, I divided x and y, and r, g, b up separately, because one's for the position one's for the color. 

But I could actually put these all in one line of code. So now, I have five variables all declared at once. And then in draw, I'm giving all of those variables a hard coded number. 

So we have a white circle in one spot. But what if I were to allow each of those to be random? Look at that. Every time, through draw, a new circle is drawn at a random location with a random RGB value. 

Maybe I want to constrain the range of color a bit more. At a minimum, the blue value will always be 150, and the red value will always be 100, and maybe the green value is always going to be very little-- just between 0 and 50. Varying degrees of pinkish-purple. I like that. 

Ooh, what if I add some alpha? Over time, the shapes are blending. It's a nice pointillist effect. Something else to mention is that while I said that the random function takes two arguments, a minimum and a maximum, if your minimum value is 0 you can actually give random just one argument. 

So this can actually be written as random just 640, and it will assume some random number between 0 and 640. So back to the code, I can remove that, this, and this here. And there we go. 

And while we're at it, I should probably use the built-in variables width and height so that if I resize the sketch, it will always still spread the dots out all over it. So let's say x equals random width and y equals random height. Hopefully, you have so many ideas percolating in your head, you just can't wait to add random all over your code. 

Maybe you're going to make your own pointillist design like this-- try other shapes besides just dots. What happens if you put random lines all over the sketch? Ooh, that's a nice idea. Could you make a random design, like my example of a new random house, every time you run the sketch? 

You could also go back and explore that painting program, the one where the dot smeared around based on moving the mouse. What if, every time you click the mouse, you started painting with a new color? Or maybe there's some other way you could use random in combination with the size of the dot or the color that I can't even think of right now? 

So go and explore the random function. See what types of designs you can make. Take a break for yourself, and then when we come back-- oh, it's going to be time! 

We're going to get that ball. That ball is going to hit the edge, it's going to bounce, it's going to turn. It's going to be a thrilling moment. I'll see you then. 

[MUSIC PLAYING] 

[WATER SPLASHING] 

Welcome back. I had a break for a few days. Wearing different clothes. I am just full of energy, raring to go because, even though I say this a lot, this section might be the most important part of everything you might ever learn to do as it relates to coding. 

You haven't really been able to do very much. You can make drawings, you can add some color, you can animate things. But without the ability for a program to make decisions and take different paths based on conditions that are happening within the program itself, there's very little you can do. 

And this is what we're going to cover. It is called a conditional statement. The grand finale of this section will finally answer the question, how do we tell this circle that when it leaves the screen-- it goes past the edge of the canvas-- how do we tell it to turn around and move in the other direction? This cannot be done without a conditional statement. You might recall back when I was talking about setup and draw, I said, oh, this thing about a block of code with an open curly bracket and a closed curly bracket, that's going to be very important. 

[MUSIC PLAYING] 

A conditional statement is a new kind of block of code for you to write. It has an open curly bracket and a closed curly bracket, and lines of code that go in between those. Lines of code are only executed if a certain condition is met. 

So we have a new reserved word in Processing, if. And in fact, I often say an if statement rather than a conditional statement, because that's what I'm doing. I'm saying, if this condition is met, execute these lines of code. 

So this begs the question, what goes inside here? What goes inside these parentheses? What goes inside here is known as a Boolean expression. 

A Boolean expression is any code that evaluates to one of only two options, true or false. Let's think about this concept just with things that we might say to each other. I mean, you're not really there, but I think that you're there. 

I might say I'm wearing a sweater. I mean, that's true. I'm wearing a sweater. It evaluates to true. This learn-to-program video that you're watching is absolutely a fun-tastic-- 

[THUDDING NOISE] 

--oh, ow. So in these statements I'm making, sure-- yes, some of them might be factually true or factually false, but there's also maybe some subjectivity to things that I might say. Maybe it's true, or maybe you might disagree-- it's an opinion. 

None of that is the case in an actual Boolean expression that we would put in code. A Boolean expression that we put in code is always true or false. One very common way to create a Boolean expression is with something known as a relational operator. 

An operator is something that acts on numbers. I talked about arithmetic operators like add, subtract, multiply, divide. A relational operator is an operator that compares two numbers. Greater than, less than, greater than or equals, less than or equals, equals, and not equals. 

Now, these are a little bit funky. I'll come back to them another time, but let's just consider right now greater than, less than, and greater than or equals, and less than or equals. Let's say I were to write 18 greater than 10. 

This is a Boolean expression. Does it evaluate to true or false? Yes, it's true. What about 18 is less than 10? 

That evaluates to false. What this means is if I were to write a Boolean expression inside the parentheses, like if 18 is greater than 10, run this code. This code will only run if this is true. 

Now, you might be thinking, what the-- huh, ah! This doesn't make any sense. Why would you do that in there? That's always true. This code always runs. 

This is not the point. The point is I want to somehow use a relational operator in combination with a variable. If that number is changing based on what's happening in the code, then sometimes it will be true, and sometimes it will be false. Here's a really good example. What if I want the background color of my sketch to be blue when the mouse is on the right-hand side, and I want it to be red when it's on the left-hand side? 

If I have a canvas-- if 320 is the x position of the center of the canvas-- if mouseX is greater than 320, execute this code. Let's see how that works in practice. Let's start over with a brand new sketch. The only thing it's doing is drawing a black background. 

And let's add that conditional statement. Remember, I need the keyword if. I need parentheses with a Boolean expression inside. mouseX is greater than 320. And then any code inside the curly brackets will run if the Boolean expression evaluates to true. 

Remember, setup runs once. Draw is looping over and over again. So it's going through and saying, hey, I'm going to draw the background is black. 

Let's check where the mouse is. Oh, that's false. Skip that line. Draw the background is black. Oh, check where the mouse is. 

That's false. Skip that line. So this line of code, line 10, is never being executed. Now, I'm going to slowly move the mouse. This is very dramatic. 

Maybe we need a drum roll, some dramatic-- oh, no! It's too late. It happened already. This might be helpful if I were to draw a line. 

With that line, now I can see, as soon as the mouse goes over here-- oh, and look at this! I always forget about order of operations. Where did that line go? 

Well, because this if statement is happening after drawing the line, it's covering it. This is actually kind of an important note about background, which I never specifically said. Background doesn't draw a color in the background behind things. 

It just fills the canvas with a color, which typically you use to set the background. But it's only actually going to be the background if it's at the beginning of draw, and you're drawing everything else on top of it. So that's kind of an important thing for you to note. 

Here we go. White background, black background, white background, black background. That is the core idea of a conditional statement. Now, this might seem a little bit insane to you, but I would make the argument that I could actually stop this Processing course right here, and I've given you the tools to program anything you might ever think of or imagine. 

Everything else that we do from here on out is something that will ultimately make things easier, or organize your code better, and be able to build much more complex and sophisticated concepts. But this is a good time for you to play around with this idea of an if statement. Think about the painting program. What kinds of things could you do with the painting program if you had the ability to use a conditional statement? 

Do you have any ideas how you would get that ball to turn around based on a conditional statement? See if you can experiment. Use mouseX, use mouseY, use your own variables, try greater than, try less than-- all of these things. See where you can get to. I'm going to take a little pause, and I'm going to come back and continue showing you more about what you can do with an if statement. In fact, I'm going to show you something about a word-- oh, it's a wonderful word in programming-- called else. 

[MUSIC PLAYING] 

I am just dying to know what it is you were able to accomplish with just a basic if statement, but there is more to just if. Let's look at this example. Yes, the background turns white when I move the mouse over here and black when I move there, but it's written in kind of a strange way. 

Like, I'm always drawing the background black. And then as long as I put this mouseX is greater than 320 thing next, it will cover it with white. But really, what I'm saying is, if the mouse is greater than 320, draw a white background-- otherwise, draw a black background. 

And this concept of otherwise is something you can actually write into your code-- only you need to use the keyword else. An if statement can be combined with an else by placing the else right after that closed curly bracket, and then putting in a new open and closed curly bracket. 

Now, any code inside here will run if this Boolean expression evaluates to true. If it evaluates to false, it will skip this code and go and execute this code instead. There we go. Same exact result, only I feel like the code makes more sense now, and is more readable and understandable. 

While it totally doesn't matter here, it's also a bit more efficient. It's not drawing the black background an extra time when it doesn't need to. I think what I'm trying to emphasize with else here would be a bit more clear if I drew shapes instead of filling the background color. 

[MUSIC PLAYING] 

The if statement here is now going to draw a circle whenever the mouse moves past the halfway point, but that square is always there. If I want the shape to change, I could write another if statement. Now, this is working as I intended-- circle, square, circle, square. 

But I wrote it as two separate if statements-- completely unrelated. Now, this is something you might want to do for conditions that you're testing that have no relationship to each other. But in this case, there is a relationship. 

If it's over here, draw a circle-- otherwise, draw a square. That's where the else really makes the most sense. There we go. 

Another example of how the conditional statement-- the if statement-- can change what is rendered each time through draw depending on what I'm doing with the mouse. What if, instead of just having two areas-- one for a circle, one for a square-- I were to think about the canvas as divided into 3? And I'm going to change the width to 600 because 640 doesn't divide evenly into 3. 

Just because I drew the lines there, still the exact same behavior. But now, I want to see maybe a line for here, a square for here, and a circle for here. So it turns out that in addition to having an else that is paired with your if statement, you can also have an else if. 

Once again, a nice way to think about this to help you understand it is to look at this word else and substitute the word otherwise. If the mouseX is greater than 320, do this thing. Otherwise, if the mouse is greater than 400 do this other thing. 

And otherwise, in all other cases, do this last thing. So for any conditional statement-- I'm thinking about this whole thing as a conditional statement-- you always have to have at least an if. Optionally, you can have an else, but you can only ever have one else-- that otherwise in all other cases. 

Now, you could actually insert as many other else ifs as you want in between this beginning and end. Let's take a look at that in the code. Let's change 320 to 200. 

Let's say else if, now, mouseX is greater than 400, draw the square. And then in all other cases, I'm going to draw a line. So I just did some quick math in my head to draw a diagonal line. We'll see if we got-- if I got that right. 

Great. All other cases, draw that diagonal line. Now, if the mouse is greater than 200, draw the circle. And otherwise, if the mouse is greater than 400-- ah! Why is that wrong? 

Take a look at that code. Syntax-wise, I have not made any error. The program runs. Processing is not telling me anything is wrong with this code, but the result is not what I intend. 

Why is that? It's very important for me to mention that only one of these things can ever happen-- only A, or B, or C. It can never be both A and B, or A and C, or B and C, or all of them. 

So why is B never happening? Well, let's think about the number 450. Is the number 450 greater than 400? Yes. So if the mouse is at 450, this would be true, but we've got to start here. 

450 starts here. Is 450 greater than 200? Yes, it's also greater than 200. So shape A is going to be drawn-- the square. Once a Boolean expression in an if statement-- in a conditional statement-- evaluates to true, you immediately skip to the end and go on with the code. 

So only if this is false do we ever come and check this. And then only if this is also false do we ever execute C. Knowing that, how would I fix this? Think about that. 

There's two solutions. Well, there's more than two, but there's two solutions that I'm thinking of here that I'm curious if you're thinking about. Solution number one, I could check 400 first. If I check 400 first, 450 is going to trigger the circle. 

And I wanted it to be a square, so maybe I should be consistent, not that it really matters. These are arbitrary choices. But 450 is going to trigger the square and then skip to the end. 250 is not greater than 400, so the square will not be drawn, but the circle will. 

Line, circle, square. Yes! Now, the other solution I was thinking of was changing the greater than to a less than. 

Now, again, where which shape goes, that's made up. But I'm trying to be consistent, although I wouldn't be surprised if I got it wrong. Now, if I run it, line, square, circle. Exactly the behavior I was looking for. 

I also kind of like this because I'm used to the English language, and I read from left to right. I realize that might not be the case for you. But now, I actually have also the code in that order. 

So I'm checking this section, then this section. And this section is the all other cases, which kind of makes it a little easier for me to parse. It's also maybe worth noting that this kind of behavior would be really hard to do without the concepts of else if and else linked to an if statement. If you only can make separate if statements, you'd have to jump through a lot of hoops to have one thing happen, but not the other thing. 

Here's an exercise for you. How about you take my code-- maybe instead of columns, you try making rows that the mouse moves up and down and changes what's being displayed. Could you create four sections? 

The reason why this is a really good thing for you to try is that you'll need to have two else ifs-- if else, if else, if else. So give that a try. And after you're done, if you keep watching, I'm going to demonstrate yet again one more thing that you can do with these statements. It's not about changing the if or the else if, but it's actually changing the way you form your Boolean expression with a logical operator. 

[MUSIC PLAYING] 

Now, it's time to look at logical operators, and by that, I mean AND, OR, or NOT. So why are these needed? Let's consider this square. 

I want now to implement a basic rollover functionality. When my mouse hovers over the square, it lights up and just brings a smile to my day. So how do I know if the mouse is hovering over this square? 

Well, if this edge is 280, I can say if mouseX is greater than 280-- now, I'm not going to draw the square in the if statement. I'm always drawing the square. The only thing I'm going to change is what the fill color is. 

Fill 255. And now, I'm going to have an else, and I'm going to say fill 175. Let's try this. Oh, beautiful. Look at my rollover. 

Well, it's not perfect, because it still lights up if I go up here. Over here, it's lighting up. I only am checking that one left edge of the square. What if I want to also check now if it's less than 380, which would be the other side of that square? 

Well, something weird that I could do, that I don't really suggest-- although, it's good to know that this is possible-- is I could put an if statement inside of this one. So I could also say, if mouseX is less than 380, fill 255. So look at this. 

Aha. Oh, wait a sec. Ah! Wow, I've really messed up this logic here in such a weird way. I would actually now have to put another else in here that would say fill 175. 

I would have to put the else there. Now, I'm saying, OK, first check if it's greater than 280. Oh, no-- but in all other cases, I also need to fill 175. Oh, this is awful. 

I hate what I'm doing, but at least now it works. Still the vertical edges don't change anything, but now the horizontal edges do. But this is really awful and convoluted. What I really want to say-- the reason why I put that extra if statement inside is I want to say if mouseX is greater than 280 and mouseX is less than 380, that's when I want to light up the square. 

AND is an example of a logical operator. The three logical operators are AND, OR, and NOT. And you can use them to join more than one Boolean expression together. If you have two Boolean expressions with an AND, they both have to be true for the end result to be true. 

If you have two Boolean expressions with an OR, only one of them has to be true for the end result to be true. Now, let's get rid of this awful if statement inside of an if statement, and just say AND mouseX is less than 380. Now, I have some bad news for you. You can't actually just say AND. 

It's not going to be that bad, but this isn't going to work. Syntax error-- it's not actually missing a parentheses. It doesn't know what AND is. So in some programming languages, the logical operator AND is just the word AND, but in Java, which Processing is built on, this is not the case. 

And AND is written as 2 ampersands, and OR is written as 2 pipe symbols. I'll try to show you where that is on the keyboard if that's unfamiliar to you. And a NOT is an exclamation point. 

But again, we're not really talking about the NOT just yet. Welcome back to that in a little bit, because I also want to talk about NOT equals. Drum roll, please. 

[DRUM ROLL] 

There we go. Working as expected, but I would really like to have the ys working also. I only want it to light up when the mouse is within that box. Luckily for me, I can keep joining ANDs. 

I can have four things. If all of them are true, that's the only time you'll ever execute the code within that block-- within those curly braces. So I can actually say, AND-- so I don't love how long that line of code became, and there are other ways to reorganize. 

And refactor is a kind of a fancy word for reorganizing your code to make it a bit more readable. But this is going to get me the functionality that I want right now. If all of those things are true, and only if all of those things are true, fill 255, otherwise fill 175. 

I must have an error here. Oh, my goodness! It's not working! This is not 180. That would be half the height. The height of the square is 100, so this should be 230. 

But really, we could protect ourselves against these kind of errors if I were using variables, because I could say-- I'm going to use w to indicate the width of the square, which is the same as the height. So now, I'm checking if mouseX is greater than x, and it's less than x plus w, and if it's greater than y, and less than y plus w, now draw the square at x, y, w. 

And the reason why this is awesome is because now-- ah, I'll just change the x and y of the square-- make it bigger-- and it still works. All of the code is pulling from those three variables. Look at this. We just programmed a rollover. 

It might seem like a lot of extra effort to have to program all the pieces of a rollover from scratch, essentially, as opposed to just saying put a rollover here. And in some environments, like if you start to work in the browser, there are a lot of built in interface elements that you get for free depending on where you're programming and what you're creating. But this is a really nice way to learn coding-- is to say, what are the basic kinds of interface elements I use every day? 

A rollover, a button, something that toggles on and off, or something where you hold the button down, this happens. And I have two other things that I think would be interesting for you to try. One is, what if this were a circle and not a square? How would you detect if the mouse was inside the circle? 

To accomplish this, it's a little tricky. You're going to need to think about the circle's radius, which is half of the diameter, the diameter being the argument you put into a circle to draw it. And then you're also going to want to look into a function called dist for distance. 

I'll make sure I include an example of how that works. And if you've got questions about it, definitely leave those in the comments as well. But I've got another interesting challenge for you. Let's put the square back in the center. 

And by the way, the correct x value for it to be centered was 270, not 280. My math was off before. The y would be 130. And let's make it 100 in width. There, the square is at the center. 

Here's the challenge. Instead of it turning white when I roll over and going back to gray, what if, when I roll over, it still turns white, but then when I roll out, it fades away? How would you accomplish that? It's not really about if statements, but this is a nice way to synthesize a couple of different concepts that I've been showing you. I'm about to give you a clue, so if you want to try it without the clue, pause right now. 

[MUSIC PLAYING] 

If you do want the clue, the clue is-- and usually, whenever ask a question like this, the answer always is you need another variable. So you need another variable. What is changing now? It's not just white or gray. 

It's changing over time. You're going to need a variable for that. So give that a try, and then I'm going to come back. I'll show you the solution, and we're going to look at some other things. 

We never looked at OR, for example. And I think a nice place where we're going to need OR-- we can finally get back to that ball that was flying off the edge and left. Let's see if we can make it bounce back and forth. It's going to be an exciting and momentous occasion for us both. 

[MUSIC PLAYING] 

How'd you do? Let's see if anything you did resembles the way I just coded it just now. I didn't actually check to see if my code worked, but luckily for me, it is working. Whenever I move outside of the square, it fades away. 

So how did I accomplish this? I added a new variable. I called it squareBright. Maybe you can think of a better name for that-- for the brightness of the square. 

It starts at 0, which is why when the program first runs, you're seeing it as black. Now, critically, I am always calling fill by that brightness and always drawing the square. So it's not about, do I sometimes draw the square or not draw the square? Do I sometimes fill it, not fill it? 

I'm always filling it, always drawing it. The difference is that brightness value changes. It always, every time through draw, fades away. So even if, right now, it started at 0 and is fading away, negative numbers for Processing are the same as putting in 0 for color. 

Not for everything, but in the case of fill, negative 5 is the same as 0. But any time I hover the mouse inside the square, the brightness is set to 255. Now, it's not fading out even though I'm saying square bright equals itself minus 5. 

I set it 255, I draw it at 255, then it becomes 250. Repeat draw-- set it to 255, draw it at 255, then it becomes 250. It only will render it at 250 if I move the mouse outside of the square, and then it's going to do that many times per second. Here's another version of the same concept, but with the window divided into four quadrants, each one fading out as you move from one to the other. If you want to give that a try, pause right now. 

[KEYBOARD TYPING] 

Here's the solution. I just need four separate variables, one for each quadrant. And I need to use if and else if to figure out which one am I hovering in, and which variable gets set to 255. Then I'm drawing all the rectangles, decrementing all the values, et cetera, et cetera. 

This one's a bit longer. There's more stuff to it. Maybe you want to print it out, and put it under your pillow to sleep with it at night, and let it soak into your brain a bit. But I'm here. I'm ready to move on. It's time to finally see what can we do to make that ball turn around when it hits the edge. 

[MUSIC PLAYING] 

As promised, here we are. The ball is moving. It's about to hit the edge. What do we do? Well, let's think about it. 

What is the condition that would evaluate to true if the ball hits the edge? The edge is pixel 640. Of course, I always say that, but technically, if the width is 640, the pixels actually go from 0 to 639. 

It's just, saying 639 is not a fun number to say. So let's just go with the edge being 640, even though that's technically one pixel past. So let's start with something simple. Instead of having a turn around, let's just have when it gets to the edge for it to reappear back on the other edge. This is actually easier. 

And in fact, we know how to get it to reappear by setting x to 0. We were doing that with clicking the mouse. So let's actually get rid of this mousePressed function, and let's add an if statement in draw. 

If x is equal to 640, then set x back equal to 0. Now, this is incorrect, and Processing is already telling me it's incorrect. Why is it incorrect? 

Remember how I kept saying I was going to come back to this-- double equals. We know equals is syntax you can use. When I want to initialize a variable, I set it equal to 0. 

When I want to increment, I set it equal to itself plus 2. So equals is the symbol you use when you want to set a variable to equal a certain value. It's an assignment operation, but that's not what we're doing. We are writing a Boolean expression. 

I don't want to set mouse equal to 320. I want to know, does mouseX equal 320? That's a question. In Java-- or Processing which we're working with in this case-- the Boolean operator for checking if two things are equal is two equal sign a-- double equals. 

So that's how we differentiate between asking the question, does this equal this, or saying, I want this to equal this. Add another equals, and let's run this sketch. I'll wait. 

[TRIUMPHANT MUSIC] 

Yes! This is awesome. Let's have it move a bit faster. Oh, that's too fast. Let me change that to 7. 

Oh, wait. What happened there? We're thinking the same thing again, right? If I'm adding 7 every time to x, it's possible that x is never going to actually equal 640. 

I mean, 640 divided by 7 does not result in a whole number. So the ball is actually going to jump over pixel 640. So this is a case where even though I wanted to demonstrate double equals as the Boolean expression for checking if two values are equal, it doesn't really make sense to use here. 

What I really want to use is greater than or equals. This will account for any time the circle reaches the edge and hits it exactly or jumps over it. So there we go. 

Now, this is a perfectly looping circle. It will never stop. It will always reset. But it's not turning around, is it? 

How do we get it to turn around. I don't know how you're thinking about how to do this, but a common mistake, and I think the way that I like initially thought when I was first trying to learn this stuff was, OK, I got it. I know that it should be plus 7 to move to the right, and it should be minus 7 to move to the left. 

So why don't I put plus 7 in here, and then I'll use that fancy else that we learned about to otherwise say it's minus 7. Let's see what happens. Whoa. Ah, what? 

Well, clearly our logic is flawed. So I already know what's wrong. Maybe you do too, but this is a nice opportunity for me to look at the print line statement again. I want to look at the value of x every frame. 

And something else that I could do here is I could slow down the program quite a bit. So this is something that I haven't explicitly addressed. I mean, I've talked about how the draw loop happens over and over again, but how fast does it happen over and over again? On some level, it's just trying to do it as fast as it can, but it's actually locking it into a certain number of frames per second. 

This is the way we talk about animation typically. How many times do we redraw the image per second to create that illusion of motion? It's going to be smoother the more times we draw it per second. 

So if I say one frame per second, it's actually-- we're going to see it happening much more slowly. And it's just going to the left. It's just going negative and negative. 

Why is that? Well, x starts out at 0. And if x is greater than or equal to 640-- oh! Oh, my logic must be wrong. 

[LAUGHING] 

I only want it to go negative if it's greater than, so let's fix that. No problem. This must be right, now, right? This is promising. 

The circle is moving to the right. I mean, I left the frame rate at 1. I probably now want to let it run faster, but good thing-- good news for you. I can just speed up the video and then slow it down to see what happens when it gets to the edge. I mean, is it going to turn around when it gets greater than or equal to 640-- x will equal x minus 7. Let's see what happens. 

[MUSIC PLAYING] 

It's that 602. Here we go. It's going to get to 640 really soon. What happens? Oh, 64-- what, what, what? 644, 637, 644. Look at it. It's just moving back and forth like that. 

It's stuck. Well, I'm really glad I printed out the values because I can really see what's going on, and it kind of makes sense. If it's greater than 640, slide it back. 

But then the next time, it's not greater than 640, so it's going to move again. Oh, that's greater than 640. Slide it back. That's why it's moving back and forth. 

So this logic is wrong. I don't just want to decrease the value of x once. I want to decrease it continuously, and then maybe when it hits the other edge, increase it continuously. You know what we need? We need another variable. 

We need a variable for that value 7. I'm going to call that speed. So x is always going to change by speed. I'm going to take out the frame rate, I'm going to take out this else, take out this. 

I'm going to run this. x always changes by speed. What do we want to do when x gets to the edge? We want the value of speed to change. The value of speed should now be negative 7. 

If speed is negative 7, x equals x plus negative 7 is the same thing as x equals x minus 7. Whoa! Oh, so close! But now you should know what we could do. 

If x is less than or equal to 0, speed equals 7. Yes! (CHANTING) Bouncing ball back and forth. Now, this is something we can improve. One thing that's kind of clunky here is I wrote speed equals 7 here. 

Let me take the print line out. We'll put it back if we ever need to debug. What if I don't want it to be so fast? Let's make it 4. Here it goes, here it goes, here it goes. 

Oh, all of a sudden, it's faster. So I changed this speed to 4. Oh, but now I got to change it in other parts of the code, which is fine. I could, but ultimately, I don't want to set the speed to a specific value. 

I want to just take the speed and reverse its direction. So if I have a positive number that I want to be negative, whatever that number is, what's an operation that I can apply to it to turn it into a negative? Multiply by negative 1. 

Speed equals speed times negative 1. But what if it's negative, and I want it to be positive? Well, guess what? A negative times a negative is a positive number. 

So I can also put here speed equals speed times negative 1. And there we go. It's working. And whatever value I start the speed at, it's always going to be the same speed. Look at this. 

I've got the same exact line of code in both of those if statements. If x reaches the right side, reverse the speed. If x reaches the left side, reverse the speed. 

What am I really saying here? I'm saying, hey, either case, if it's on the left or the right, reverse the speed. Did you hear what I just said? I just said OR. We used AND before. That was kind of logical. We wanted to have the mouse x position greater than this value and less than this value. 

Now, we've got a situation where an OR makes sense. If x is greater than or equal to 640 or x is less than or equal to 0, invert the speed. Oh, that's just beautiful. I love a good old-fashioned bouncing ball. 

What is next? Let's add a y. And of course, I should really be using width and height, not the hardcoded values. There we go. I've got an x and y, and now I need separate variables for the x speed and the y speed. 

Oh, I also want to draw the circle at x, comma, y. Then I always change x by x speed and y by y speed. And then I've got one if statement. If it's on either the right or left edge, reverse the x speed. If it's on either the top or bottom edge, reverse the y speed. 

And there we go. If you feel so inclined, you could replace that circle with a nice DVD logo. I don't know about you, but this is very satisfying to me-- the fact that we have this circle bouncing beautifully off the edges. Using conditional statements is really a matter of practice. All I've done is show you all of the components. 

I've covered if, else, if else. We've looked at what a Boolean expression is, how you can make them with a relational operators, how you can join them with logical operators. You're just going to need to rinse and repeat this over and over again. 

And in fact, that's what I'm going to be doing as I get to the next example, the next example, the next example in future sections of this video. I do have a couple more things I want to show you I think before I move on. Let's take a moment to pause. 

How about you try expanding this bouncing ball a little bit? Now, you might be thinking, oh, I know what I want to do. I'm going to add a second circle, and maybe a third, or a fourth. I would say hold that thought. I mean, certainly, if you want to try having two, that just means you need two sets of variables-- x1, y1, x1speed, y1speed, x2, y2, x2speed, y2speed. 

You can see how that could quickly become unwieldy, and I'm going to look at specific techniques for duplicating a concept in your code multiple times later. What I might suggest is think about other things that could happen when the circle hits the edge of the canvas. For example, what if it changes color every time? 

What if its size is always changing? It hits the edge, it gets bigger, and it's shrinking until it hits it again? Maybe the speed changes each time it hits the edge. Ooh, I know. This is a hard one. 

What if it was accelerating as it moves down, almost like a gravity simulation? Give that a try. See how you can expand this bouncing ball sketch. 

I'll come back. I'll show you some solutions and then kind of wrap things up. There's some missing pieces here. I'm going to talk about what it means to have a variable whose type is Boolean. 

That's kind of an important concept that I haven't explicitly covered here. So that will wrap up the conditional statement stuff, and then we'll move along from there. So take a little break, and see you in a moment. 

[MUSIC PLAYING] 

How did that go for you? This is what I did while you were working. I made it so that every time it hits the edge, it picks a new random color. I also made the speed random every time you run the sketch. 

So you can see here initializing xspeed and yspeed as a random number. I've got new variables for r, g, b. Oh, I did another thing. I added a variable for radius, which means when I draw the circle, I need to say radius times 2, because radius is half the diameter. 

Why wasn't my variable called diameter, you say? I could have done that, but the reason why I picked radius is I'm now checking the edges as the width minus the radius-- half the size of the circle. Or instead of at 0, I'm checking the radius-- half the size of the circle. That has a result, if I slow it down to show you, of the circle actually really bouncing off the edge. 

It feels a bit more realistic in terms of the walls of the canvas. You can see here that in addition to reversing the xspeed and the yspeed, I'm picking all new random values for r, g, and b. and otherwise, most of the code is the same. So what do I want to show you next? 

Let's think about this feature that I might want to add. What if, whenever I click the mouse, the ball stops if I release the mouse, it keeps going. Well, I know I have a mousePressed event, but before I get to the mousePressed event, let's look at something else in the Processing reference. 

Look here under Mouse. So first of all, there's a lot of other functions related to interacting with the mouse, but I want to point out that there's a mousePressed parentheses, and then there's just a mousePressed on its own. Well, the mousePressed parentheses is the documentation page for that mousePressed event that I've already talked about. 

mousePressed-- not the function-- happens to also be a built-in variable. Just like mouseX tells you where the mouse is, mousePressed tells you whether the mouse is down or not. Now, this brings up a really fascinating question. What is the data type for mousePressed? 

mouseX-- the data type for mouseX is integer-- any whole number. mousePressed, the data type is actually Boolean, meaning the value of mousePressed can only be one of two things-- true or false. And right here on the Processing reference page, that if statement-- the Boolean expression-- is checking if mousePressed is equal to true. 

Now, this is a very verbose way of writing that. Let's put it in the code. And by the way, I only want to move the x and y value if the mouse is pressed, so I'll put those statements inside. If mousePressed equals true-- oh, I wanted to do-- I wanted to do it the other way around, but I'll show you that in a second. 

So now, I click the mouse and it moves. I release the mouse and it stops. x and y are only changing if mousePressed equals true. Equals false-- now, it's moving. But if I hold down the mouse, it stops. 

Release the mouse and it goes. I was saying this is verbose because if a variable's type is Boolean, you don't actually need to check if it is equal to true or false. It's evaluating itself as true or false. So I can actually just say if mousePressed. Same exact result, but quite a bit simpler. 

And this is finally time now for us to fill in this last logical operator. NOT is an operator that you can apply to a Boolean expression to invert the trueness or the falseness of it. Not true is false, not false is true. So right here, I can say if NOT mousePressed-- NOT mousePressed is false, because mousePressed is true, so NOT is false. So I don't move it! 

There's so much more to this. I could just be here for like weeks at a time. But I'm just trying to show you the core basic components. And really, it's just going to be about practicing and mixing and matching things, trying out your ideas, asking questions, and so on and so forth. 

Hopefully, this is helping you, but I still have more even in terms of just these fundamental pieces-- the building blocks-- of conditional statements and Boolean expressions. Here's the last bit. I don't want the ball to stop when I'm holding down the mouse and go when I release the mouse. I want to be able to just click the mouse and have it stop, or click the mouse and have it restart. 

I want clicking the mouse to actually toggle it on or off. Using the mousePressed variable inside of draw is a way of determining if you're holding down the mouse. You're checking it continuously. mousePressed-- the function-- the event that I talked about earlier-- is a way of knowing if you just did a single click. 

And once again the answer to this problem that I'm trying to figure out is, I need another variable. I can't use the mousePressed variable, which is always going to go on and off based on whether I'm pressing the mouse. I want my own variable. My own switch is the ball going. I want to be able to turn that on and turn this off. 

So that's where I could create my own variable of type Boolean. Let's call it going and have it be set to false. If going, change x and y. Run this code-- it's never going to move. 

Going is hardcoded to false. Nowhere in the code anywhere do I set it to true. Add the mousePressed event. And in here, I'm going to say going equals true. Ready? 

Drum roll. Here we go. Press the mouse, and it starts. Now, I'm going to press the mouse again. 

Well, any time I press the mouse, going is still going to be true. I never set going back equal to false. So how could I have it the next time I go through mousePressed, I set going to false? 

Well, if going is true, then I want it to be false. Otherwise, if it's false, I want it to be true. So I could actually say if going, then going should be false. Otherwise, going should be true. 

So I now have this extra if statement that's checking whether going-- oh, this is another thing I need to print out and put under my pillow, I think. If going is true, it becomes false. If going is false-- if I go to the otherwise, and then it becomes true. Let's see if this works. 

There we go. It's not moving. I click the mouse-- going is now true. It's moving. I click the mouse again-- going is false. It stopped, and so on and so forth. 

There's another way we could write this. And this is another one of those things like-- well, this is kind of a lot of lines of code for a very simple operation of just flipping a switch. Well, the NOT operator is our friend here, because what if I were to write NOT going? 

What does this mean to you? If the value of going is true, then NOT going is false. If the value of going is false, then NOT going is true. NOT false is true, NOT true is false. 

So what I really want to say inside of mousePressed is going equals not itself. I want to take this Boolean variable and invert its truthness. False becomes true, true becomes false. 

Not moving. Click the mouse, moving. Click the mouse, it stops. It works. Oof, that was a lot. 

This, by the way-- unlike the rollover functionality or the holding down the mouse functionality, this is like a button toggle. It is something that happens and sets a state every time you press that particular button. So here's an exercise for you. Maybe you can take a bunch of these concepts and put them together. 

Could you now create a square somewhere on this canvas-- there's a bouncing ball, and every time you click in the square, maybe it changes the color? Maybe it stops it and starts maybe it changes the size. Could you create an interface to control the way the ball is bouncing? 

Give that a try. This is actually the end of this whole section on conditional statements. It's an incredibly important fundamental part. You could really stop here, not do any of the rest, and just make lots of stuff with drawing, and variables, and conditionals. 

And I encourage you to do that for quite some time before you come back. If you've been frustrated by the fact that I'm only ever drawing one thing onto the screen, stick around. Because when I come back, I'm going to look at something called a loop. Now, a conditional statement tests a Boolean expression and does something or doesn't do it. 

A loop can test a Boolean expression and repeat something over and over again. So just sit with that for a minute. Take a break, come back, and I'll be showing you all sorts of stuff with loops. 

[MUSIC PLAYING] 

Welcome back. One beard trim later, and it is time to tackle loops in programming. 

We just spent a lot of time talking about if statements or conditional statements. An if statement is what is known as a control structure in programming. It controls the path that the program is going to take. If some Boolean expression evaluates to true, then execute this code, otherwise do this, otherwise do this, and so on and so forth. 

This even has yet another name. If we're talking about it as a control structure, it's often referred to as a selection control structure. But there's another kind of control structure for iteration, or repeating something multiple times. And if "if" is for a selection control structure, the word for an iteration control structure-- well, there's actually two options-- a while and a for. 

Now, a for loop is probably the one that I use 99 times out of 100. And most likely, you're going to find yourself using for loops over and over again. So you could make-- and I've heard this argument before-- just skip the whole while loop thing. 

But I actually find the path to best understanding for loop is to take an if statement, transform it into a while loop, look at all of the details of how the while loop works, and then move on to for loop. So that's just how I've decided to demonstrate this to you today. 

[MUSIC PLAYING] 

So why do we even need loops in the first place? Let's write a nice sketch that draws a whole bunch of circles on the screen. 

[MUSIC PLAYING] 

And there we go. 5 circles each, 50 pixels in diameter, and spaced out by 50 pixels each. This is all well and good, but you can see where I'm going with this. It's one thing to type out five separate lines of code for five circles, but what if I want to have 50 circles, or 500 circles, or 5,000 circles? 

This is a totally reasonable thing to do in Processing-- draw lots and lots of the same thing over and over again. And it would be pretty insane for me to have to write 500 lines of code just to draw 500 circles. This is where a loop comes in again. 

Again, I'm starting with the while loop. With an if statement, I would say if some Boolean expression evaluates to true, execute some lines of code. A while loop looks exactly the same. 

While some Boolean expression evaluates to true, execute some lines of code. The key difference here is that, if this is true, the code is only going to execute once. This code will continue to execute over and over again as long as this Boolean expression, whatever it may be, continues to evaluate to true. 

So let's say, at the top of this program, I'm going to declare a variable x, and I'm going to start that value at 50. Now, in draw, I'm going to say while x is less than width. As long as the value of x is less than the width of the canvas, draw a circle at x-- [? y, ?] 180-- and 50 pixels in diameter. 

Now, looking at this code, I have an immediate problem. Let's see what happens if I run this. It's very dangerous what I'm about to do. I do not recommend, if you're following along with me, you also run it, especially if you have lots of other important things open on your computer. But I'm going to take that risk right now. 

We don't see anything. The background hasn't even been drawn black. No circles appear. It is stuck in what is known as an infinite loop. At the moment, we are testing if x is less than width. And we know we initialize x to have the value of 50. 

So we're essentially asking the same question over and over again-- is 50 less than width, is 50 less than width? And the answer is always true. Shouldn't we at least see one circle, maybe the background? 

[LAUGHING] 

By the way, the fan on my computer is starting to really go now. We don't see anything because the sketch hasn't even made it to the end of draw for the very first time. Remember, everything that happens in draw is happening off-screen, and then at the end of draw, it updates it to the display you're actually looking at. 

So while there's nothing syntactically wrong with what I wrote, it is fundamentally flawed logic-wise. And I'm spending a lot of time showing this to you because this is going to happen to you. Even once I show you how we break out of this loop what is the proper way to think about and write a loop, it's impossible not to make the mistake of writing an infinite loop every so often. 

And fortunately for us, even though this particular program is frozen, it hasn't shut down or messed up our entire computer. I can still go to the browser, and click around, and then come back to Processing, and hit Stop to get out of that loop. So whenever you write a loop, you've got to make sure that you're thinking about something called an exit condition. 

And here, the way that I can have an exit condition is to manipulate the value of x during the loop. So maybe the first time through the while loop, x is 50, then it's 100, then it's 150. So at the end, if I were to say x equals x plus 50, then every time through this loop, by the time I get to the end, we increase the value of 50, draw the circle again, increase it by 50, draw the circle again. 

And eventually, at some point, x is going to be greater than width. This will evaluate to false, and we'll exit out of the loop, and continue with the code. Let's take a look at that. 

I don't see any circles! But I do see the background. We're not stuck anymore. You have to remember something that's really odd about what we're doing here. 

So even though here I am in a vacuum-- this little section of this long course all about Processing-- I'm just talking about a while loop. But I can't forget about the context that I'm in. I'm writing the while loop in this draw loop. 

So draw is actually looping. Oh, this is very confusing. But let's follow the code. I have a global variable x, which has its initial value of 50. Then I draw the background. I say I'm going to draw anything white, and then I draw a circle at 50, then at 100, then at 150, then at 200, 250, et cetera, et cetera, until eventually I get past 640. 

The while loop exits, and we go back to draw again. What's the value of x? The next time through draw, the value of x is now already greater than the width. 

So really, what needs to happen is every time in draw, I need to start with x having the value 50. And there we go. This is the result I was looking for. I only have one line of code that calls the circle function, but I've wrapped it inside of a loop to implement some logic to call circle many, many times within one cycle through draw. 

I could make these circles 10 pixels. And now I have many, many more of them. Looking at this code, it resembles very closely the code that I wrote just to move something across the canvas itself. Look, there's a circle. 

It's drawn at the value x. And every time through draw, x is moving up by 1. But we want to see just one circle, and we want to move it one time every cycle through draw to create the illusion of motion. Yes, draw is a loop, but it's loop is for the purpose of animation. If what we want to do is repeat something multiple times inside of any given frame of that animation, that's where we need a while loop, and eventually, in just a moment, a for loop. 

[MUSIC PLAYING] 

But before I'm ready to move on, I want to point out something really critical here. In this sketch, I've declared a global variable float x equals 10. That's the way I've been declaring variables all along. They're always at the top. 

I use them anywhere in the code-- setup, draw, mousePressed, et cetera. But here, the value of x has to be reset back to 10 every time through draw in order for this while loop to perform the way I want it to perform. So while this code works-- and it's really fine-- there's nothing inherently wrong with it-- this is a really good time for me to introduce another concept about the way that variables can be declared and used. 

And there's a reason why I spent all this time talking about the variable as a global variable, because you can also have what is known as a local variable. And in this case, I really only need that value x just for the purpose of this while loop. x exists solely to draw a whole bunch of circles at once, and then I'm done with it. 

So that means I can delete float x equals 10 at the top. And just make sure that in draw, when I'm first going to use x, I give it a data type. I'm essentially declaring x inside of draw. This means if I were to say something like x equals 10 in setup, the error is the variable x does not exist, because it doesn't exist in the land of setup. 

Any variable declared within a block of code between any given curly brackets is only available to you inside of those curly brackets. Now, this might just seem like some conceptual thing right now-- like, why do I care-- why would I use one versus the other? I think this will make more and more sense to you over time. 

But I would say that the reason right now I don't want to have as a global variable is just much neater and tidier. Like, I just want my x to be right here with my loop. That's all it's for. I don't want to use it anywhere else. 

And maybe I actually might want a different x somewhere else in my code, and this would allow me to do that. Variable scope. This is the concept of scoping your variables. There's no reason to scope your variables in a wider way than where you need them, because that only introduces a little bit of extra confusion. Let's turn now to the for loop. 

[MUSIC PLAYING] 

So we've established an example while loop that looks like the following. We have a variable called x that we initialize to 0. Then, I use the keyword while followed by a Boolean expression. 

Open and closed curly brackets. And inside those curly brackets-- inside this block of code, I perform some action, like draw a circle. And then increment the value of x so that at some point, the Boolean expression evaluates to false, and the code can move on. 

This style of loop is so commonly used that the for loop exists to take all the parts of it and condense it into one line. Let's take a look at how that is written. I'm here to tell you that these two loops are exactly the same. 

A for loop is created with three parts. There is the initialization, the Boolean test, and an incrementation operation. The order of these is precisely the same as what I've written here. The very first thing that happens is a variable is initialized. X is declared as a floating point value and initialized to 0. 

Then, the Boolean test is evaluated. If x is less than width, then we execute whatever code is in here, like draw a circle. Then, at the end, the incrementation operation is performed, x goes up by 10, the Boolean test is done again. 

If it's true, we draw the circle, do the incrementation operation, check the Boolean test, do the code, et cetera, et cetera, so on and so forth until this Boolean test finally evaluates to false. In which case, the loop is then exited, and whatever code happens after is then run. In some ways, I really love the while loop because it's written in a way that's more clear to me. 

This initialization happens at the start, then we check the Boolean expression, draw the circle, increment x, check it again, draw the circle, increment x, check it again. Maybe it's false-- exit the loop. Things happen in the order that they're written. 

But this for loop is exactly the same, and it's just a very common conventional way of writing a kind of loop. Now, we're just kind of in the place where it's useful to practice them both. There are some rare occasions where you really need to use a while over a for loop. 

And probably as you get more comfortable with programming, you're going to focus on using for loop most of all. So let's go ahead and try adding that into our code itself now. I'm going to comment out the while loop so that we can keep it there for reference. 

And by the way, I can comment out a whole block of code by highlighting it, and then using Command-Slash or Control-Slash on Windows. for initialization condition, semicolon, Boolean test, semicolon, incrementation operation. Open curly bracket, closed curly bracket, and then whatever code I want to happen over and over again inside that loop, I put between the curly brackets. 

So when I hit Run, we should see the exact same result as what I had with the while loop. And there we go. This is also a nice moment to just be reminded of the fact that there's always a shorthand for these incrementation operations. Instead of saying x equals x plus 10, I can just say x plus equals 10 for the exact same result. 

Also just to be consistent, I'll have x start with 10 since that's what I did with the while loop. This is a great time to pause. Why don't you try and see what kinds of designs can you make with a for loop or a while loop. Could you make colorful stripes, maybe vertical ones, horizontal ones? 

What other kinds of shapes can you repeat? Could you make a set of concentric circles, where the loop is altering the diameter of each circle every time through? Another thing that's fun to try is, what kinds of designs can you place onto a grid, like a checkerboard. Feel free to give that a try, but when I come back I'm going to show you how to do that by nesting one for loop inside of another one. 

[MUSIC PLAYING] 

I hope you had fun experimenting with loops. Let's take a look at a particular scenario that is incredibly common in computer graphics. It's a grid. Admittedly, this is a rather poorly drawn grid, but I think you get the idea-- a system of columns and rows. 

This could be relevant for a game that you might be designing. An image made up of pixels is organized into columns and rows. So many different scenarios that you might find yourself wanting to program are going to involve something like this. 

So a good place for me to even just start is, how would I draw a grid of squares filling up a canvas? Let's begin by creating a variable called spacing. Spacing will refer to the size of every square-- every cell on that grid. I want x to begin at 0. I want to go all the way to the edge, and I want to increment x by spacing. 

Then, I want to draw a square instead of a circle. And the size of the square is spacing. There. You can see I have a line of squares across horizontally. 

I'm going to say no fill and stroke 255. There we go. Now, what I need to do is I want to take this concept of having all of the columns, and I want to duplicate that for every row. 

So this value 180, if I have that be 0, we'll see the squares across the top. If I change that to 20, we'll see the squares across y equals 20. So instead of a hardcoded value for y, what I want is another loop. And I want that loop to wrap around the x loop. 

And then this 20 becomes y. And there we go. There's our grid. Essentially, what I'm saying is for every y, draw a whole bunch of squares for every x. Start with a y and do the x loop, then increment y and do the x loop again, then increment y and do the x loop again, and so on and so forth. 

And here, we see that outer loop y with an inner loop of x. And that actually doesn't matter, because I'm drawing the whole thing at once. I could have the x loop be the outer loop. That has the exact same result. 

But now, conceptually, what I'm doing-- I'm starting with one x, drawing all the y's, incrementing x, drawing all the y's, and so on and so forth. What's fun about this is I can just adjust that spacing variable. There it is with 50. 

Now, notice the width and height don't divide evenly into 50, so it's a little bit off-kilter. Here's some exercises you could try, and I'll include solutions for them. What happens if you take that spacing variable and change it over time? 

Can you zoom in and out of this grid? How about making this a grid of circles instead of squares. You might discover that the reference point of a circle being the center is going to make this a little trickier than you might imagine. 

This is a little bit of an aside, but this is a wonderful spot to look at something called 10 print, a really famous pattern in the history of computer graphics, which originated from one single line of code on a 1980s Commodore 64 computer. To get there, let's look at what happens if we add some randomness-- remember the random function-- into our grid. 

I'm going to take out no fill. I'm going to fill every square with a random color-- grayscale value. Now, notice how much that's flickering. This is because, remember, there's a draw loop. And every time through the draw loop, I'm picking new random values for every square. 

I can move all this code into setup so it only happens once. But just quickly right now, I'm going to add the function call no loop in draw, which causes Processing to run draw only once. There. 

Now, I have a grid of random grayscale squares. What if, instead of a square, I draw a diagonal line from the top-left to the bottom-right of each cell of the grid? So that would be from x, y to x plus spacing, y plus spacing. 

It looks like I've just drawn a series of diagonal lines across the space, but really these are lots and lots of small diagonal lines in every single cell of this grid. I'm going to make this stroke weight 2 so that they're a bit more visible. Now, what if I wanted to draw all those lines in the inverted direction? 

So instead from the top-left to the bottom-right, what about from the bottom-left to the top-right? And this fill random is no longer relevant. So that would be from x, y plus spacing to x plus spacing y. 

There. The lines are all now shifted. The pattern that I want to show you emerges when the lines are now randomly drawn either one way or the other way-- essentially, a forwards slash or a backslash. This is how it was done on the original Commodore 64 with printing forwards slash and backslash. Now, we're just drawing lines. 

So I need some way of essentially flipping a coin. Well, what if I pick a random number? r is a random number between 0 and 1. It's a floating point number, so there's a 50% chance it'll be greater than 0.5 and a 50% chance it'll be less than 0.5. 

So I can actually just put that into an if statement. If r is less than 0.5, draw the forwards slash line. Actually, that's the backwards slash line, but just pick one of them. 

Otherwise-- else-- draw the forwards slash line. You ready to see what this looks like? Wow! Suddenly, we have a maze pattern. 

So just the simple idea of random lines one way or the other on a grid pattern, we can create this incredible intricate maze. This is one of my favorite patterns you can do with a simple for loop. 

Now is a great time for you to make your own version of 10 print. I've actually done an entire separate video about coding 10 print, and many, many people have submitted all sorts of beautiful variations on this pattern. If you make your own, I'll make sure to include information in the video description on how you can submit yours to the catalog of Coding Train 10 print designs. 

So we're now at the end of the section on loops. I've given you just the basics of how a while loop works, how a for loop works. We've looked at a few different examples, and how we can even nest them to make a grid. It's certainly something that you're going to have to take quite some time of practicing that I'm going to have to come back to over and over again in future examples that I'm demonstrating down the road, but I think we can safely move on. 

So take a little break for yourself. Practice different patterns and designs, make your own 10 print. And when I come back, I want to look at something called an array, which is highly linked to the concept of loops. 

[MUSIC PLAYING] 

All right, folks, we are really starting to put all the pieces of the programming puzzle together. I have talked about variables, conditionals, loops. There's not a lot that just those concepts you can't program, but let's take a look at what I have going on here on the screen next to me. 

I have this bouncing ball. It has some variables-- an x, a y, an xspeed, a yspeed. It has some conditionals. If x reaches the edge, multiply xspeed by negative 1, and so on and so forth. 

Below, there are seven-ish bouncing balls. We know that a loop is something that can be used to iterate-- to take this idea of drawing a circle and draw one multiple times. But there's a lot more steps in between just this idea of a basic loop and taking this concept of a bouncing ball and duplicating it. 

I mean, if I have an x and y for one bouncing ball, then do I need another x for the second, and another x for the third? I'm going to have so many variables. Ultimately-- and I want to mention it now because it's really important-- I want to package up everything that has to do with that bouncing ball into something called an object. 

But before I even get there, I want to just talk about what it means to have a variable that can store a list of information, because this is going to be something really important. Eventually, I want to be able to have a list of bouncing balls. So I'm not going to get all the way there in this section, but I am going to look at this concept of an array, a list of data, and look at how that relates to loops that we just covered. 

Where to begin? We're comfortable with this idea of a variable. Float x equals 100. I want to introduce now the concept of an array. 

Now, in truth, an array is a kind of variable. It's a kind of variable that stores a list of things as opposed to a singular thing. But just for the sake of argument right now, let's think of the variable x as having one number. And what if I have an array? Let's call that array values, and I want it to have multiple numbers. 

The way that I can hardcode a list of multiple values is, once again, using curly brackets. Now, these curly brackets are not a block of code. There's no code that goes in there. I mean, there's stuff that I'm going to type in there, but nothing executable. 

The curly brackets, in this case, mark the beginning of the array and the end of the array. Then I can store multiple values separated by commas. But this begs the question, what is the data type of values? 

The data type of the variable x is a floating point value. The data type of all of these inside of this array are floating point values. So I must write float here, right? 

But that's not enough. To declare an array and specify its data type, you need both the data type itself, float, but also you need an open and closed square bracket. Yeah, I know. We've been using curly brackets a lot in our code. Now is the time with arrays to use square brackets. 

In case it's not obvious to you, there's a space there. So I'm saying just like float x, I'm saying float values, but I'm putting an open and closed square bracket next to float to indicate that this is an array. Now, I will say that this is a pretty rare way to initialize an array with a predetermined set of values, but it's a really good way for us to just ease our way into the concept of arrays by having a prefab-- it's all finished-- it's a list of four values. 

Let's go put this in our code. Now, actually, I want this data to mean something right now so that we can come up with an arbitrary example scenario. I really love fruit. Do you love fruit? Let's think about this as an inventory for fruit. 

I've got 5 mangoes, 22 blueberries, 7 Kiwis. And my favorite-- I've got 11 plums. Now that I think about it, let me make these values bigger, because I'm going to use them to draw stuff, and pixel-wise, these are going to be kind of tiny. 

I'll multiply everything by 10. Now, I'm going to draw a bar as a thick line in the center of the canvas. So really, I wanted a rectangle here to demonstrate a bar graph, but I decided if I just make the line thick, that might make things simpler. 

But I noticed, by the way, when you make a thick line, the default way it draws it is with these rounded ends. So I can actually call the function stroke cap and change that to a square. And there. 

Now, I have my rectangle, which is just a thick line that is 50 pixels high, because I'm drawing the line to connect the center point to a point that is 50 pixels above the center point. Why am I doing this? The point is, what if what I want to do is draw this line pulling values from the array? 

Well, notice how I have height divided by 2 minus 50 there. That's the bottom of the bar minus 50 to the top. If I had a variable, like mangoes-- because I have 50 mangoes-- or let's just say 75 right now-- I could put the variable mangoes in there. And the bar would be 75 pixels high. 

I could say 25, and it's 25 pixels high. But how do I reference a value that is inside the array? And let me call that array fruit so it has a more specific name-- or I'll say like fruitInventory. What do I put there? 

[MUSIC PLAYING] 

One of the fundamental principles of an array is that it is an ordered list of information, meaning this is not just some bag full of numbers where they're just all a clump together. The order is something that is fundamental to the way this array has been defined. And every single value in the array can be specified by its index. 

What do I mean by index? If I were being super informal about this, I might be well this is the first element the second, the third, the fourth. And while that is true, the index-- the indices of an array start with 0. 

So this is actually the 0 element. Sure, it's the first element in traditional counting, but in programming, with arrays, we always start from 0. 0, 1, 2, 3. 

And remember these square brackets? Well, these square brackets are very important throughout the lifetime of an array. So if I have a variable called values that is of type array-- of floating point-- then I can work with any one of these values that is inside the array by referencing its specific index. 

So if I were to say values, square bracket, 2, closed square bracket, which element of the array am I talking about? I'm talking about the third element, or index 2-- 0, 1, 2. And this is the answer to what I put where those question marks are. 

I can now say fruitInventory index 0. What will I see? I'll see a bar of height 50 pixels. Oops, I forgot my closed parentheses. 

There we go. Let's change that value to 1. Let's not use values that will go off of the canvas, so let me just change that to 100. Great. 

And if I use index 2, I'd see 70. Index 3, I'd see 110. Now, here's a question for you. What would happen if I typed the index 7 in here? 0, 1, 2, 3. 

There is no index 7. Let's run the sketch and see. Array index out of bounds exception. Welcome to an error message that you will see a lot starting today. Fortunately, it's pretty helpful here. 

It says index 7 out of bounds for length 4. The array is of length 4, and we just tried to reference index 7. So referencing an element that doesn't exist breaks your code. 

Now, what if what I want to do is every time I click the mouse, I see the next element of the array visualized? I know I need the mousePressed event. 

And now, what I need-- yeah, the answer, again, is a variable. I need a variable to store the current index into the array that I want to display. So if I add a variable called index-- oh, wait. What's its data type? 

My example is a little silly in that I made my array of numbers floating point numbers. So technically, I could say 100.3. That would be a valid number here. Although, in terms of a fruit inventory, does it make sense to have 10.3 mangoes? 

But this is not what's critical here. The point is-- what I am trying to demonstrate is that I can have an array of any kind of data. In a moment, I'll show you an array of strings of text because I think that's a useful demonstration. 

And I'm mostly just using floating point numbers in all of the examples, because it's kind of the most general purpose kind of number. However, this is a moment where I must use an integer, because if I am going to use a variable to talk about the index into an array, this index cannot be 2.2 or 2.7. 

It has to be a whole number. And Processing-- the Java programming language-- will not allow you to put a floating point number in as the index to an array. So at this moment, I now must create a variable-- let's say I'm going to call it index-- of type int for integer. 

int index equals 0. Let's plug in index here, and let's run the code. We're seeing the first element index 0 into the array. That's what's being drawn. The height of 50. 

Change this to 1. The height is now 100. I can now add, in mousePressed, index equals index plus 1. So now, when the sketch runs, fruitInventory 0 is 50. I click the mouse. fruitInventory 1 is now 100, 70, 110. 

[LAUGHING] 

Not the most interesting demonstration visually, but I am showing you how this works. I now have a list of numbers. I have a variable that tells me where in that list I want to currently be examining and looking at in order to draw something. And then when I click the mouse, I change that number. 

And any time I want to access something from the array, I have to give the name of the array, square brackets, and the specific index into the array. Just for fun-- I mean, maybe this is all just for fun. I have no idea. 

But just because this is a nice moment to do so, let's look at a different data type besides just a number. So I've been looking at floats for floating point values. I just talked about how an integer is for whole numbers only. 

A string is a data type for a string of characters-- a piece of text. So data type is string. Then I need a variable name. Maybe I call it message. 

Then I set that equal to a string of characters, which is enclosed in quotes, and I'll call it rainbow. That's my message. My message to you all is rainbow. Semicolon to end the line of code. 

Let's look at that in our code. So I'm going with fruit, so I'm going to say string fruitName equals mango. And then if I want to draw a text to the canvas, your friend is going to be the Processing reference where you can see all the functions having to do with text. 

I happen to know them for the most part off the top of my head, so I'm just going to put them in. I'm going to say textAlign center, because I want my text to be centered. textSize-- I'm going to say 64 because I want to use a font size of 64 point. 

Then, the text function will draw my fruitName. And I want to give it a location, I'll say, in the middle, but maybe down 64 pixels. And by the way, fill is what would set the color of the text. So it's using a default fill of 255, but I could be more explicit and actually put it in there. 

So this is showing what I wanted to show. And when I click the mouse, it's going to go to the next element of the array fruitInventory, but the fruitName is still mango because I just have a singular variable. However, if I wanted it to be a list of strings, then I can add the square brackets here that tells Processing that fruitName is going to be an array. 

Now, maybe I want to add an "s" there. That's just for my own personal code hygiene. Because it's going to be a list of things, I'll give it a plural name, but that's not at all required. Then, I need the curly brackets. 

And I can say mango, strawberry, kiwi, plum. Now, I have an array of strings. And just like I can look at every value from the fruitInventory array one at a time via an index, I can say fruitName, square bracket, index, closed square bracket. 

Run this sketch. Mango, strawberry, kiwi, plum. A fruit inventory data visualization! Now, you probably can guess what the problem with this sketch is. What's going to happen if I click the mouse again? 

Array out of bounds exception. Now, this looks like a very strange message-- index 4 out of bounds for length 4. Well, if this length is 4, shouldn't index 4 be right? Remember, if the length is 4, the valid index values go from 0 to 3. Very important. 

How would you fix that? I think I'll leave that as an exercise to you, the viewer. Maybe you put an if statement there. If index reaches the end of the array, set index back to 0. 

Cycle backwards through the array. So many things you could try. What I would like to do next, however, is look at what would it mean, if I wanted to show all of the values of the array all at once instead of one at a time. Instead of having index be a global variable that changes every time I click the mouse, what if I were to iterate through all of the values of the array and draw all of them? 

[MUSIC PLAYING] 

Did you just notice that I used the word iterate? Are you thinking what I'm thinking? Maybe this thing we just spent all this time discussing called a for loop could be used in combination with an array. What do I mean by that? 

[MUSIC PLAYING] 

Let's say, for the sake of argument, that what I want to do is print out all the values of the array to the console. Well, I know there are four values-- indices 0 through 3. Print value 0, values 1, values 2, values 3, done. 

Of course, if my array has a lot more stuff in it, this is going to get very unwieldy. Didn't we just go over all of this? If I want to draw a lot of circles, I don't want to have to say circle so many times. 

Ah! I could use a for loop. for-- I need an initialization condition. I want to iterate over the index values of an array starting with 0. So I need a variable-- oh, and the index values have to be integers, so it should be type int. I'll call it i, short for index, and give it the initial value of the beginning of the array, 0. 

Then, I need a Boolean expression. I'm going to want to count through the array all the way up until-- how many elements do I have? 4. And then I need an incrementation operation. I want to go up by 1. i plus, plus. 

So this loop, if I were to just put println i in here, what would this loop do? i would start at 0, which is less than 4, so it would print out 0. Then, it would go up by 1, which is less than 4, so it would print out 1. 

Then, it would go up by 1, which is less than 4, so it would print out 2. Then, it would go up by 1, which is less than 4, so it'd print out 3. 

Then, it would go up by 1-- [GASPS] 4 is not less than 4-- exit the loop. So we would see, in the console, 0, 1, 2, 3. Funny-- that looks just like these index values. 

So if I were to put in here println values index i, this loop is performing the exact same functionality as these four lines of code. Sure, I needed three lines of code instead of these four, but if this were 100 values, I would still only need three lines of code. 

I want to talk about the number four in here a little bit more in a moment, but right now, we can just understand it as, I'm saying i is less than 4 as the Boolean test because there are only four elements. Index 4 is invalid, and 4 is not less than 4. That's why this is not less than or equal to. 

So coming back to the sketch, I now want to include a for loop inside of draw. And all of the stroke and fill settings are not going to change. So I'm going to move the line down here and just put the two drawing functions inside of the loop. 

for int i equals 0, i is less than 4, i plus, plus. Notice how a for loop, again, is a block of code. So the lines inside of that block, it's convention to indent them-- helps make the code more readable. And now, instead of fruitInventory index, let's get rid of this idea of a global variable index. 

And instead I want to display the bar associated with fruitInventory index i and the name index i. Oh, so it worked. It iterated over every single one, but it drew them all on top of each other. 

I don't mean for this to be an elaborate demonstration of best practices for design and data visualization. I'm just trying to show you a very basic example that shows how arrays work. But I think I could do something here, where I could space them out at least horizontally by doing something like-- let me create a local variable internal just to this loop called x. 

And I'm going to say x equals i times 50, so they're going to be spaced out by 50 pixels. Then, the line is at x, and the text is also at x. Whoops! That's an interesting mistake. I still have the top point always in the center. 

So the top point also has to be by x. And let's space them out by more than just 50. Better. Maybe the first one shouldn't be at pixel 0, so let's add 100 to it. 100 plus i times 100. Maybe that text is just too big. Make it 24 point. 

There we go. Again, not the most amazing bar graph data visualization ever, but you can see how with all of the data stored in arrays, fruit inventory is 4 numbers. fruitNames-- those are four strings. 

Now, I have a loop that just goes from 0 all the way up to 4, but not including 4, and draws a line. fruitInventory index i, and text fruitNames index i. Let's add one more thing. I'm feeling very hungry today, and I would like some more fruit. 

Blueberry sounds good. I've added blueberry there. And let's have 25 blueberries-- not too much. I'll run the sketch. Oh, I added another value to fruit inventory. I added the string blueberry, but I don't see it here. 

Why don't I see it there? Oh, that's because the loop is only going up until 4, but now there actually are five elements in the array. So obviously, I could just delete 4 and type 5. But something that I think is important to note is arrays actually store as part of themselves their own length. 

And this is foreshadowing something I'm going to get to later-- this idea of properties inside of a variable. What does that even mean? Don't worry. I will talk about it in great detail. 

But right now, we can understand it as, fruitNames-- I want to make sure I iterate over all of the fruitNames. I can actually-- instead of hardcoding the length of the array, I can say fruitNames.length. And now, there we go. 

We've got the blueberry as well. Now, there's a flaw here, which is that I could make a mistake and not have a matching number of fruitInventory as fruitNames, in which case, everything would break. And maybe there's a way to package those two values together instead of having two separate arrays. 

Yes, all of these are really good points! But for right now, I think this is an adequate demonstration of the core concept of an array-- of being able to initialize an array of numbers, an array of strings, an array of anything. And be able to use all of those elements by referencing it with a specific index, whether it's one at a time or a loop iterating over all of them. 

Ah, I'm trying to hold off on all of the details, because they're going to be important later after we've talked about object oriented programming. But I do think it's worth me mentioning that this is fairly atypical. It's not so often that your hardcoding a list of numbers into an array. You might be generating them, pulling them from a data source, creating them out of some mathematical function. What if what I wanted to do right now is see all of this fruit visualized, but it's a random inventory each time? One thing that I could do is I could write another for loop in setup to iterate over the array and reassign all of the values. 

Here, we see that same for loop. i starts at 0-- Boolean expression, i is less than the length of the array, incrementation operation, i plus, plus. 0, 1, 2, 3, 4, 5 elements. We picked five random values. 

If I run it again, 5 new random values. So this worked. This did the job of what I was just trying to explain. However, it's a little weird. Like, why did I pick all those values and then randomize them a moment later? 

And also if I was going to have 1,000 fruit things, am I really going to type in 1,000 numbers first just to write over them with new random values? No. So one of the things that I can do when declaring an array is just say I want to have an array with this many spots in it. 

And then in a moment, I'll fill all those spots. And the way to do that is with the following syntax. New-- this word new is important, and I'm going to talk more about it again when we get to objects. 

Float because I want to make a new array of floats. Seems very redundant, but that's just the way life is. In a strongly typed language, we've got to be very specific about everything everywhere and consistent. Square bracket, 5, end square bracket. 

So this is the syntax of declaring an array of a certain data type with a certain amount of space in it. I want to declare a variable of name values whose data type is an array of floating point numbers. And the thing that I'm going to store in that variable is a new floating point array with five spots in it. 

This syntax is a little wonky. It takes some getting used to, but it also I think will be a bit more clear to you, especially what this new word is for, once we get to this thing called object oriented programming, which is coming. Oh, I can't wait until we get there. 

new float 5. Let's just make sure this still works. And there we go. Maybe you want to practice playing around with this-- try adding an element, taking one element out, changing the way it's drawn. Just use this code and sort get comfortable with the concept of arrays. 

Maybe something you could try is having a sketch that you made have an array with several different colors in it, and that could be your color palette for various things you're drawing. What I would say is, don't try to do that bouncing ball thing just yet. Don't try to make some animated behavior of a shape that's moving around, and bouncing, and then duplicate it a bunch of times with all sorts of different arrays for all the x's and the y's. 

Don't do that. Stick with me, because the next sections where I look at, first, the basic concept of a function, and then this idea of an object, is going to lead us to having arrays of objects. And that's going to be the most powerful way to take an element that's in your animation, in your scene, in your Processing sketch, and have many of them all working together. 

But I think it is worth taking some time to just practice the nuts and bolts of arrays with a sketch like this that's graphing a set of numbers using some strings. Maybe something you try is displaying the number associated with each fruit at the top of the graph. So it might say 25, 35, 45. 

Ooh, and then could you do this? This is a little tricky. Could you total all of the values? How would you iterate over an array, and add up all the numbers together, and then display the total amount of fruit, or maybe the average amount of fruit? 

I don't know what that means exactly in this context, but see if you can just try manipulating the array by adding all the numbers together, by showing the values on screen, trying it with colors. Lots of things you could do. Take a little break for yourself, and I'll be back to talk about functions in Processing. 

Yeah, yeah, I know. Maybe you already know what a function is-- circle, line, fill, stroke, background. Those are functions. What I'm talking about is writing and creating your own functions. That's what's coming next. 

[MUSIC PLAYING] 

[TELEMETRY NOISE] 

Welcome back. I hope you had fun tinkering around with for loops and arrays. Those are fundamental concepts that are going to come back very soon as I build towards the final example that I'm imagining in this video series. 

We've got a ways to go still, but we're getting there. We're over the hump. We're past the halfway point for sure. There is another fundamental concept-- a building block that we need in order to realize all of our dreams and make anything happen in programming, and those two things are functions and objects. 

Now, for the moment, I've only written functions here on the whiteboard. Let's write objects also. And maybe I want to briefly return back to this bouncing ball sketch to illustrate what I'm talking about. Look at this program. 

There's a whole lot of variables all at the top. I'm doing some stuff in setup. I've got some stuff in mousePressed, all this code in draw. There's no clear organizing principle to how I have built this sketch in Processing, which is fine. 

The ball bounces. I love it, you love it. But what if I wanted to have more than one ball bouncing? How can I get a handle on this sketch, divide it up into parts, and reuse aspects of code I've already written to duplicate concepts within the code itself? 

Imagine if I could write a sketch that looked just like this. What if I could have one variable, and somehow inside that variable are all the properties of a ball and all the code that manages how that ball operates? I could create a new ball in setup, and I could execute commands on that ball-- bounce off of the edges, show yourself, draw yourself in the canvas. 

This is where I'm going with this idea of encapsulating all of the properties and behaviors of something that's in a Processing sketch into this idea of an object. And that brings me to the concept of modularity. How do I take a program and break it down into its separate parts and organize it in a nice clean way? 

The second core concept of functions and objects is this concept of reusability. Maybe this has already happened to you, where you've been writing a Processing sketch, and you wrote six or seven lines of code to do something. And then all of a sudden, you realize like, oh, I want to do that again-- that same thing. 

Let me copy paste those lines of code, change it a little bit, then copy paste it again, and change those a little bit. There's got to be a better way. If I have written the code to execute some kind of idea, what if I want to reuse that code several different times in a Processing sketch? 

So my goal here is to get all the way to explaining all of the details in terms of how this little preview of object oriented programming works. But right now, I want to set all of this completely to the side. Before I can get to all of the details-- I'm much too excited to talk about object oriented programming, but we're not ready for it yet. Before I can get to that, I need to just talk about what is a function, and how do you define and call your own functions. 

[MUSIC PLAYING] 

It would be completely reasonable for you to say to me right now, what are you even talking about? I know what a function is. Here's an example of one. Here's an example of another one. 

This whole time, all throughout this coding journey, we've been over and over again calling functions-- the circle function, the background function, the fill function, the stroke, the line, the triangle. Those are all functions that are defined inside the Processing code base. Our use of them demonstrates the power of modularity and reusability. 

If I want to look for the part of the code that draws a circle, I can find the call to that function. If I want to draw more than one circle, I can call the circle function twice. Somewhere behind the scenes in the larger code base that is Processing is written all of the underlying code to set the background color, to draw a circle on the screen. 

So if these are Processing-defined functions, how could you define your own function? What if you wanted to write the following code? There is no unicorn function in Processing, but if you want to write all of the code to draw a unicorn and name that function unicorn, you could call the unicorn function. 

So how does this work? How do you define your own functions? Maybe you remember way back when, several hours ago at this point, I talked about the functions setup and draw. Setup and draw control the flow of a Processing sketch. 

Setup begins the Processing sketch, runs once, draw then follows, and happens over and over again. mousePressed is one you could also have. It executes the code anytime you click the mouse. And when I looked at those, I said, don't worry about the parentheses, and the curly bracket, and that weird word named void. Someday, I'm going to talk about what those mean. 

Now is that time. Those are actually function definitions. This is the code that defines the setup function. This is the code that defines the draw function. And this is the code that defines the mousePressed function. 

The odd thing about these functions, setup, draw, and mousePressed, is that they are special in the sense that Processing is asking you to write those functions. Processing knows to look for the setup function, for the draw function, mousePressed, and knows when to execute those functions. You don't actually have to say, call setup, call draw, call mousePressed. 

But if I wanted to draw my unicorn and call the unicorn function, I would have to look for the definition of the unicorn function. And to define your own function, the syntax is exactly the same as defining setup, draw, mousePressed, et cetera. Defining a function involves four parts. 

Void-- [CHUCKLES] I'm still not going to tell you why it says void there, but I'll get to that. And I'll just tell you right now, this is known as the return type. Then there is the function name-- in this case, unicorn. It is a name that you choose to make up. 

The convention is for it to be just like a variable name. Start with a lowercase letter, you can't start with a number, and don't use something that's already part of Processing. Like, don't call your function circle. Next is an open parentheses and a closed parentheses. 

What goes in here are the function's parameters. Now, you might have noticed any time I define setup, or draw, or mousePressed, there's nothing between the parentheses. There are no parameters. 

But whenever I call the circle function, I've got to say, hey, this circle should be at this xy with this diameter. The background should be this grayscale color. The parameters are what define what arguments are expected to be sent into the function when it's executed. 

So setup, draw, and mousePressed don't have any parameters. And maybe when we start our first function definition-- when I start to demonstrate this with code, we'll leave that blank, and then slowly fill it in. I said there were four parts. 

So we have the return type, the name of the function, the parameters. And then I guess the fourth part is really just what is the code that should be executed when the function is called, and that is written inside the curly brackets. It is another block of code. Maybe this could be called the body of the function. 

I'm not sure if that's actually a term [DING] or if I just made that up right now, but it's the code that goes inside the definition. So a unicorn is probably way too much for me to try to draw right now. Let's think of something else delightful that we could draw that's not just one shape. How about a lollipop? 

It's a little bit askew. There we go. Lovely lollipop. Maybe it should be blueberry. Delicious. So what I'm doing right now is essentially going back to the beginning of this series, where all we did was draw shapes in a canvas in Processing. 

And just for the sake of argument here, let's just imagine that I also want to draw the sun shining on this lollipop, because it's a beautiful day outside, the lollipop looks delicious, and the sun is bright and making us feel warm and happy. Oh, what a beautiful scene! The sun shining on a lollipop. So this is where I want to demonstrate first the principle of modularity. 

[MUSIC PLAYING] 

What if I want to break my program into two parts, the sunshine part and the lollipop part? I need to define a function called sunshine and one called lollipop. I have no idea how to spell lollipop. I think that's right. 

So here, we've got the first three parts of each function definition. The return type, which is void-- got to explain what that means. The name, sunshine or lollipop. The parameters, which are empty-- just open/closed parentheses. And then the body of the function. 

So what goes in the body of the function? Well, for sunshine, I want the code that draws the sunshine. For lollipop, I want the code that draws the lollipop. Now, it just so happens that I wrote these functions in between setup and draw, but actually, they could be anywhere. 

I could put sunshine and lollipop after draw, before setup. I could put draw first, then setup, then the functions. These are all standalone blocks of code that execute a subsection of code. The order that they happen has to do not with where they are written in the text file itself, but the flow of the program. 

setup is called automatically by Processing first. Draw is called automatically by Processing second and looped over and over again. And then-- wait. Sunshine and lollipop are never executed. 

There is no sunshine, there is no lollipop because those are functions that I have defined. So if I want the code-- the body of those functions to be executed, I need to explicitly call those functions. And the way I do that is with the function name, followed by open and closed parentheses with anything in between that needs to be there based on what parameters are in the function definition. 

In this case, there are no parameters. So all I need to do is, inside draw, maybe I want to call sunshine and I want to call lollipop. And there we go. Same exact sketch. 

It does nothing different but I've now reorganized the code. I've made it modular. I have a sunshine function and a lollipop function. If I want to change the way the sunshine works, I know, oh, let me just go work on the sunshine function. Let me move it over a little bit. 

There. I like that a little bit better. So next, I want to focus on the concept of reusability. What are parameters, why are they there, how do you define them, how do you use them? 

But before I get there, for you, maybe now is a good time for you to pause the video, find a sketch that you wrote previously-- anything, really-- and see if you can take something that was in draw, or something that was in setup and break it out into its own function. 

Name that function, define that function, then call that function. Could you take your sketch and make it more modular by having different parts of it executed from within different functions that you define? And maybe you will have a unicorn, and a cupcake, and a puppy, and other things besides just a sunshine and a lollipop. And then when I come back and you come back, we'll talk about reusability. 

[MUSIC PLAYING] 

Now, I think that lollipop is melting under the heat of the sun too much. I want to move it over to the right. So I'll just move the circle over to like a different x position-- 350. And then I'll move the rectangle over to 340. Oh, I didn't get that right. 

I guess it's 345. You can see this is kind of awkward. And this goes back to, again, the beginning of this whole series when we introduce the concept of a variable. I want to be able to store values in variables so that I can manipulate them, and update one thing which updates other things more easily. 

This really ties in to this important principle of reusability with functions. What if I want to draw more than one unicorn? Or really, in this case, what if I want to have more than one lollipop? 

I can call the lollipop function twice. It's executing the code twice, but I only see one because there's no way to modify the way the lollipop function happens. It's drawing two lollipops, one right on top of the other. The result is us seeing just one. 

This is exactly where parameters come in. When I draw a circle, I want to give it an x and a y. Well, if this is ultimately what I want to do. I'm essentially writing another shape function in Processing. 

The difference is it's a lollipop shape, and I want to be able to define it the same way that the circle is defined in Processing by being able to draw a lollipop at a given xy. And so parameters are, ultimately, variables that are defined inside the definition of the function, and they are initialized by the arguments that are passed in. 

So I probably earlier in this video was using arguments and parameters interchangeably. I don't remember when I said which, but now is a moment for us to be very strict about that definition. The parameters are the variables you define in the function definition, and the arguments are the values that you pass into the function when you call the function. 

In other words, if I want to introduce the lollipop being drawn at an xy location, I could define an xy variable inside the parentheses in the function definition. It's the same as any other variable declaration. I need a type and a name. And then if there are more than one parameter, I need to separate them by a comma. 

So that is new syntax. The parameters are separated by commas. Processing is being very helpful to me right now in a couple of places. It's telling me down at the bottom the value of the parameter x is not being used. 

I define the parameter. I need to make sure I use it inside the code. And what do I want to do with it? I want to say the lollipop is drawn at an x and y location. And if I'm right, the rectangle should be at x minus 5, because the stick is 10 pixels wide, and I want it to be centered under the circle. 

Now, let's look at this Errors tab. And we can see here at the bottom, the function lollipop expects parameters like this-- float, float. When I run the code, the error is telling me that I have not specified the correct arguments that match the parameters in the function definition. 

However you define a function, you must call it in a way that matches it precisely. So what I need are two floating point numbers. 320, 240, 400, 240. Let's try that. And there we go-- 2 lollipops. 

And this is it. That's the basic principle at play here. I can define my own functions in order to divide the program up into different parts to help me keep things organized. 

I can also add parameters to the functions so that those functions can be called multiple times and modified, making the code reusable. So now it's really just a matter of practicing this. If you want an exercise, what I might suggest is adding more parameters to the function definition of lollipop. 

Maybe you want to add a size parameter so you can pass in how big the lollipop should be. You could do a flavor, which would map to a color. So give that a try. I know it's going to be really hard to pause the video right now, because when I come back, I am going to finally explain what this word void means and why do function definitions have return types. 

[MUSIC PLAYING] 

It's time. What does it mean for a function to have a return type, and why is it that every single function that I've showed you so far, when I'm defining it, has the return type of void? What does void mean? 

To illustrate this idea, let's consider two functions that we've used quite a bit already in Processing. The circle function, which takes three arguments-- the x, the y, and the diameter of the circle. And the random function, which typically takes two arguments-- the minimum and maximum of the range of random numbers that you want to get out. 

Both of these functions perform a task. The circle function draws a circle to the screen. The random function picks a random number. But as you may have noticed, most of the time when we write the random function, we're taking that value and putting it into a variable-- writing some code, like float r, equals random. 

You could think of the random function as answering a question, and then that answer is sent back out of the function and stored in the variable r. It returns-- notice the use of the word return there-- it returns a random number between some minimum and maximum. The circle function doesn't return anything. It just performs its task, drawing a circle to the canvas. 

This is the idea of a return type. The random function has a return type. That return type is a float. It returns a floating point number. The circle function does not return anything, but it still has a return type. 

What is that return type? You probably guessed it by now. It's void. Functions that return something return some kind of data-- an int, a float, a string, et cetera. Functions that don't return anything return void. 

So if I were writing the definition of a function that returns something like a float, instead of writing void, I would write float. I would put float as the return type. If I have a return type, I must have a statement at the end of the function that starts with the keyword return and then includes whatever value is actually being returned. So presumably, the random function has some amount of math or algorithm that picks the random number and then returns that value back at the end of the function definition. 

So nothing that I've actually shown you so far in terms of the code that we've been writing requires a function that returns a value. I have a feeling that this is going to happen pretty soon, especially once I get into objects. So hopefully, this will begin to make a bit more sense once there's a scenario where we really need it. But let's create an artificial one right now just to look at that syntax. 

How about I write a function that receives as its argument, a number? Let's say it's a distance in miles, and it converts that distance to kilometers. So the function has a return type float. I'll call it miles to kilometers. And the definition includes one parameter, the value in miles. 

And then it's my job to do the math and properly return the converted value from miles to kilometers. The formula for converting from miles to kilometers is take the value miles and multiply it by 1.60934. I think that's the precise value. 

Then, I can take that variable and return it. Let's test it. A marathon is 26.1. It's more like 26.2. I don't know if that's the precise amount, but you get the idea. 

Let me run the code. And actually, I have an error here. It's telling me the function miles to kilometers does not exist. It does exist. I've written it there. 

I made a mistake. I can see what it is. Do you see what it is? There should be a capital T. I don't remember whether I specifically said this earlier, but if I didn't, this is really important. Everything in Processing is case sensitive. 

So I'm going to get an error unless I capitalize that T. And then I realize also let me actually print the value out so we can see the result. Run the code again. There's nothing being drawn. Just to wrap up this example, let me draw two lines-- one length in miles, one length in kilometers. 

[MUSIC PLAYING] 

And now we can see I have two lines, one representing a distance-- in this case, 100 in miles-- and the other in kilometers. I really want to move on and get to object oriented programming. Oh, it's going to be beautiful. 

It's a topic that will just bring everything together. It'll help us wrap up this whole intro video series, and will just launch you off into the rest of this journey of a lifetime programming in Processing and beyond. But you should probably take a break for yourself, get some fresh air, stretch, move your body around, and also take a little bit of time to practice this idea of functions that return a value. You could try something similar, like converting Fahrenheit to Celsius. 

Maybe you have your own favorite mathematical equation that you could put into a function that returns a value. Maybe you're thinking of something even more creative that I can't possibly imagine. Give that a try, take a little break, and then we'll be ready for classes and objects. 

[MUSIC PLAYING] 

[BASKETBALL BOUNCING] 

Hi, again. Welcome. Oh, this is a momentous occasion. I know I say this basically every single time I take a break and come back, but this is the most exciting and important section of this whole video. Thank you for sticking around. 

I mean, it's been hours and hours. For me, it's been actually days of trying to record all this. And we're finally here. I'm finally going to talk about object oriented programming-- classes and objects. 

And it's going to just revolutionize the way that you think about and are able to organize your code and make Processing sketches, hopefully, for the rest of time, or however long you choose to program in Processing, or whatever you choose to program in. Remember this example that I made back in the section on functions? We have these two lovely lollipops and the sun shining down on them. 

I mean, maybe we should think of them as flowers because it's a little weird to have the sun shining on the lollipops. But that's not the point of what I'm saying. What I want to talk about now is how we think about the elements that live inside a Processing sketch. 

Learning about functions introduced you to the idea of reusability and modularity. And in fact, we have a modular program broken into parts, and we're able to draw the lollipop twice reusing the same lollipop function. But if I want to carry this idea forward, and I want to start to have those lollipops or flowers animate-- maybe they grow, maybe they bloom. 

I want to have the sun-- maybe the sun sets and then the sun rises. It would be very hard for me to continue this line of thinking with only functions. I need something more. Let me go back to another previous example. This is the bouncing ball sketch from the section on conditionals. 

The code, the way I've written, is probably unrecognizable to you, but just let's look at it for a second. Let's just read it. Ball equals new Ball. Wait, where's the x, where's the y, where's the xspeed, where's the yspeed? 

There is none of that. There is just this idea of a ball. ball.update, ball.show. Where's the code where I call stroke, and fill, and circle to draw the actual bouncing ball? All of that code is actually in an entire other part of this Processing sketch-- a different tab. 

I can click here on ball, and suddenly, I see those variables, and I see those calls to fill, and circle, and all of that logic to move the ball. This code is the embodiment of the first principle of object oriented programming encapsulation. What do I mean by encapsulation? So every example that I've written so far generally just has one page of code, and it has a setup function and a draw function. 

At the top of the code are usually many variables-- the global variables for the sketch. Another way I could describe those variables is the data of the sketch. Then, inside setup and inside draw is typically all of the logic of what's happening in the sketch. 

How are we manipulating the variables, what are we using the variables to do? Are we using the variables to draw things, to test some logic, to perform interaction with a person who's operating the sketch? Many lines of code full of assignment operations, conditional statements, loops, all that stuff. 

That I might refer to as the behavior of the sketch or the functionality of what the code is doing. Encapsulation refers to the idea of packaging the data and functionality together into one thing-- an object. Now, to be clear, even though I'm talking about a Processing sketch, I'm not suggesting that we take the entire Processing sketch and package it into an object. 

A key element here is thinking about what are all the different parts of the Processing sketch, and how do we divide them up into a collection of different kinds of objects. But for simplicity's sake, the examples that I'm starting with are things like the bouncing ball, where the whole sketch is just one ball. 

So I'm going to make one ball object, and that's the whole sketch. But keep this idea in the back of your mind, because as we move forward, I might have a sketch that has lollipop objects, and sunshine objects, and all sorts of other kinds of things inside the sketch. Let's think again about a flower. 

What are the data of a flower? Another way I could ask that question is, what are the properties of a flower? Well, maybe the properties are things like the number of petals, maybe what color is the flower, what is the height of the stem. I could keep going, obviously, but this is the data. 

Now, I want to ask, well, what is the functionality of a flower? And again, another way I could think about that is what is the behavior of a flower. Maybe I could come up with things like the flower will grow. Maybe the flower will bloom. 

And I'm writing those with parentheses because they are functions. These are variables, these are functions. And remember, the idea of object oriented programming is to take a concept, like a flower, and package-- encapsulate-- all of its data and functionality into one thing. 

But there is a really key element that I have not yet described to you. I keep using the word object. Here, I have a marker object. I have a glasses object, I have a shoe object. 

I'm talking about things in the real world-- the physical world that I inhabit as physical objects. They exist. I can see them, I can touch them, I can operate them. That-- this is going to sound weird-- is very different than the idea of a marker, the idea of a shoe, the idea of glasses. 

In object oriented programming, we have the concept of a class and an object. Right here on the board, this rectangle-- this box-- is not an actual flower. It is just the description of what it is to be a flower in the world. The concept of a flower is a thing with this data and a thing with this functionality. 

This is the class. An actual flower itself-- I don't have one, sadly. I really should have thought of that in advance. But if I could walk in here and show you a flower, that would be an instance of an object. 

The class is the template-- the source code, if you will-- for making an actual instance of an object of the type defined by the class. This is also a key point. Any time you declare a variable, you need a type and a name for that variable. 

Maybe there's a score that's a floating point number that has an initial value of 100. When you make a class-- when you build the template for an object, you are defining a new data type. It's not a float, it's not an int, it's not a string. It is a flower. 

This is really exciting and is exactly what I want to slowly, step-by-step, show you all the bits of syntax you need to learn, and how to write your own classes, and generate your own object instances in your code. I have a confession to make. I'm very tired of the bouncing ball. 

Let's try something a little bit different-- honestly, something a little bit simpler-- that will help me focus on the important details about classes and objects. I have a sketch here that I have just made, and it is called a bubble. I'm going to run it. 

And we have this lovely little circle floating up to the top, and off it goes. In the code, I can see that I have an xy. That is where I am drawing the bubble as a circle. And then I manipulating the xy by moving it up by a random amount, and also moving it left and right horizontally by a random amount. 

My goal is to write a bubble class from which I can make a bubble object, and then another bubble object, and another one, and just fill the screen with bubbles, all the while only having one set of x's and y's in my code because of object oriented programming and encapsulation. Now, I'm going to approach this kind of in reverse you can't have the object without the class-- the template. So it would make sense to write that template first, but I want to look at the code for operating the object because it will actually give me the instructions for how to design the class. 

The variable in my sketch will be of type bubble. I haven't been explicit about this yet, but any time you write a class defining a new data type, that data type, the convention is for it to start with a capital letter. This allows you to easily differentiate it from just any other variable name. 

This is a type. It's a type that I'm going to make up, but it is different than an actual variable. The variable should start with a lowercase letter. This is like any other variable declaration. I have the name of the variable, bub. 

It's a little bit of a weird name, but it's what I picked right now. And then I have the type, which is a new type that I'm about to define in a class. The type is bubble. To initialize a new object, there's a new keyword for you to learn, and guess what? That keyword is actually new. 

bub should store-- it should equal-- a new bubble object. Yes, this is a little bit redundant, but this is the way of the world. We define a variable of type bubble. And then what do we store in that variable? A new bubble object. 

And I will get to more about what's really going on here, and why we have the keyword new, and why are we saying bubble again here, why are there parentheses here. I'll get to that soon. Now, remember, an object has both data and functionality. So we don't see the data right now. I'll tell you that the data is all being initialized as part of this call to new Bubble. 

But I do want to see the functionality. The functionality-- the behaviors of an object are accessed through a new kind of syntax called the dot syntax. I reference the variable, bub. And then I can execute any function that is part of the bubble class with the dot. 

So maybe I'll have dot update. I'll call my function update to update the location and properties of the bubble. I could call it like ascend or float. I probably don't want to call it float, because float would be confusing since there's the data type float, but you get the idea. 

It's the functionality-- anything that you might choose to call a particular behavior of a bubble. And then I also want to have another function called show. I could call it render, I could call it display, I could call it draw even. But I'm going to call show, meaning that's the functionality of the bubble that draws itself to the Processing window. 

So this is our goal. I want to take this program that has setup, and draw, all these variables-- change it to look exactly like this and have it produce the same exact result. So now, let's talk about how you write the class. 

A bubble class is yet another block of code. We start with the keyword class to say we're about to define a class. We must specify the name of this class. Again, the convention is to use a capital letter. 

It'll work if you don't, but it'll make me very uncomfortable, so I really suggest you capitalize the names of your classes. And then we have an open curly bracket and a closed curly bracket. So everything that goes inside those curly brackets is all about defining the data and functionality of the class Bubble. 

So what data do we need? Well, this is a very simple sketch. I'm just starting with a bubble as having only two properties, an x and a y. There we go. 

Now, you might be saying to yourself, oh, I know! These are local variables. They're not global. They're not outside of setup and draw. Their local only to the class Bubble. 

Well, that is correct in a way. The term for these is actually instance variables. It's a fancy way for saying these are the properties of any bubble object. Any time I make a bubble object, there will be an x and a y that are properties of that bubble object. 

Now, I haven't initialized those variables yet. I'm going to come back to that. Put a pin in that. Let's look at how I would define the functionality of the object. 

Well, guess what? All of that work we did to learn how to define a function, it's exactly that same syntax. The only thing that's different is we define the function inside the bubble class. So instead of there being a setup, or a draw, or a mousePressed, or a lollipop, or a sunshine function-- a sort of global function, if you will-- I am putting a function inside the bubble class. 

And inside those functions is where I can implement my logic. Maybe in update, I want to decrease the value of y by some random number so that the bubble floats upward in the Processing window. And then maybe in the show function, I want to display the bubble as a circle with some given hardcoded diameter. 

But if you're thinking what I'm thinking, it probably would make sense at some point to make this also a property of the bubble. But I'll leave that to later maybe even as an exercise for you. We're almost there. I have pretty much all the pieces. 

I have the main sketch where setup and draw is, where I am declaring the bubble object, initializing it, and operating it with functions update and show. I've written most of the Bubble class, defined what properties are part of the bubble-- the data, the instance variables-- and I've implemented the functions update and show right here that manipulate the data and use it to do things like draw stuff onto the window. 

But I missed a really key part, and I left it to the end because it is a little bit confusing, and it's the newest aspect of all of this. I never initialized those variables. I never talked about why I say new Bubble here. The missing piece is something called the object's constructor. 

The object's constructor is a special function that's called with the keyword new. When I say new Bubble with those parentheses, it executes the code that is inside these curly brackets. The function's name is Bubble, with a capital B, matching the class name. 

The parentheses are where I might define some parameters, which I'm going to show you in a little while. And then the curly brackets define where the beginning and end of the function is and. What goes in there? Well, lots of things could go in there, but typically speaking, that's where I want to initialize the objects variables. 

The constructor you can think of as the setup function for a class. What happens at the moment that the object is created? And here, maybe I just want to define the location of the bubble. 

And there we go. This is it. This is everything. We have all of the syntax for how to write a class-- a template. Remember, there will be no object if all you do is write the class. 

The class is the instructions for what an object should do when you've actually created one by calling new Bubble, the name of the class. Then, you have that object stored in this variable, and you can operate it with different functions. 

It's time to put that code into action. So the question that you're probably wondering is, well, where do you write the class? A class, like all the other things I've been talking about, is a new block of code, and I actually could put it anywhere. 

I could put it at the top, I could put it in between setup and draw, I could put it below draw. But something that I like to do, and is somewhat conventional with Processing, is to use the feature of the Processing editor that has multiple tabs to write your classes in a new tab. It just helps you keep the code nicely organized. 

So I'm going to go up here and click this Down Arrow. I'm going to select New tab. I'm going to name the tab. It doesn't have to be the name of the class, but that's going to make things easier to follow and understand. 

So I'm going to call it bubble. And then now, right here is where I'm going to write the Bubble class. I've kind of gone over all of it already, so I'm mostly just going to type it, but I'll try to talk and give you some reminders as I'm typing it out. 

I'm declaring a class. The name of this class is Bubble, and I've got an open and closed curly bracket. A bubble has two properties, an x and a y. And the constructor is a special kind of function. 

It doesn't have a return type, so I don't have to write void or figure out what it's returning. It's actually returning an object of type bubble, but we don't have to specify that because that's just what constructors do. They construct the bubble object and they return it. 

I'm going to initialize the variables x and y in there. And then I want to write the functions for the bubble, update and show. Both of these functions don't return anything, so the return type is void. They also don't have any parameters, so there's nothing between the parentheses. 

As we move forward and I make a few additional examples, you'll see when, oh, I might want to have a function inside of a class that receives arguments. Oh, I might want to have a function inside of class that returns something. So all of that is possible, but in this basic foundational example, I'm not having any return type or any parameters. 

What goes in update and show? Well, the nice thing is I actually already have that code written. I want to manipulate the variables in update. So let me take this out and paste it in here. And I want to draw the bubble in show, so let me cut this out and paste it in here. 

Now, again, the names of these functions update and show, I made those up. It's something that I tend to do a lot with things that are animating. I want to have an update function and a function that draws it. 

And the fact that I'm putting these statements in one function versus these statements in another-- again, these are all personal style choices in the way that I like to organize my code. They're not rules. You might like to write and organize your code in a different way. 

And there we go. This is the entire code for the Bubble class, unless I made a mistake that I haven't yet discovered. But when I run it, we'll discover if I made a mistake. I don't think I did, though. I guess we'll find out. 

Now, no longer do I want an x and a y here in the main part of the program. Instead, I want one variable of type bubble. And I'll use my silly variable name, bub, because it's, hey, bub, my friend the bubble. 

And then in setup, I will initialize the bubble. Again, I could write that up here, but I'm just sort of writing things in the longer way just to demonstrate. And then in draw, I want to call update. Again, remember the dot syntax-- bub.update. 

I'm accessing the function update that is part of the class Bubble. And then bub.show. Ready, everybody? A drum roll, please. 

[DRUM ROLL] 

We did it! We took that entire sketch that was not object oriented and, in some short amount of time, turned it into a sketch that has a Bubble class and a single bubble object. One of the things that is really wonderful about this, in the sense that we've made this program modular-- we've separated out the different functionality of the bubble into two different functions-- I can do things like, comment out just one function that I'm calling on bubble. 

This can really help with debugging, because now if I run it, the bubble isn't moving. Again, this is such a simple scenario. There's nothing really going on here, but this ability to be able to turn on and off different pieces of functionality very easily, because I've separated them and encapsulated them into the Bubble class, can be really, really helpful. 

I have an exercise for you. Actually, I have two exercises for you. You can do both, do one, or just keep watching because I'm going to move on with this to the next step. 

But one thing I might suggest is find something that you've made previously in Processing that was not object oriented. Could you examine and analyze that code to try to figure out how you would encapsulate the concept of what it is that's in your sketch into a class? So maybe you drew a beautiful flower. Could you make a flower class that has the variables you need for that flower, and the functions that you need that are presumably animating and drawing that flower? 

Exercise number two. Take a look at my bubble sketch here. Could you take this sketch and add a second bubble? What would you need to do to add a second bubble? 

Could you add another property to the bubble? What about the size, what about the color? What would it mean to add another property to the bubble? 

Maybe you add another function to the bubble. Could you add a bounce function or some type of check edges function? What do you do when the bubble reaches the top of the window? 

So give those things a try. When I come back, I'm going to specifically look at both of those things. I'm going to add some functionality. I'm going to look at making more than one bubble, and that's going to lead me to what is perhaps the most confusing aspect of all of this. I'm going to show you why you might want to include arguments in the constructor-- define the constructor with parameters in order to initialize and create your bubble objects. 

[MUSIC PLAYING] 

Welcome back. While you were taking a break, I added something to this sketch-- a new function that's part of the Bubble class that checks to see if the bubble leaves the window and then restarts it at the bottom. In the code, you'll see there's a new call to that function, bub.edges. And then in the Bubble class, you'll see I've added a new property r for the bubbles radius. 

I'm drawing it with the diameter, so that's radius times 2. That's actually going to become important for something I'm going to demonstrate to you in a little bit. And here's the edges function. If y is less than negative radius, reset it to the bottom height plus radius. 

So when you were playing around with the sketch, maybe you tried to make more than one bubble. I wonder how that went? I'm going to do that right now. I'm going to call the bubbles bub0 and bub1. 

I could call them anything. I could call them funbubble, and curiousbubble, or I could call them bubble1 and bubble2, but I'm choosing 0 and 1 because you can probably imagine-- remember that thing called an array that I talked about a little while ago? At some point, I'm going to make an array of bubbles. 

And remember, when we're counting through an array, we start at 0. So I think it's going to be a little more clear if we practice that even with our variable naming right now. bub0 should be a new bubble. bub1 should be a new bubble. 

Then, I need to call all the functions on bub0 and bub1. Now, I just said this. I'm going to say it again. You know about an array, so an array would certainly make more sense. 

If I want three bubbles, four bubbles, five bubbles, am I really going to keep duplicating the code like this? But for right now, just to demonstrate the idea of more than one object, let's look at it in separate variables. Time to run the sketch. 

And there we go-- two bubbles. I cannot emphasize this enough. This is kind of incredible. I didn't make a single change to the bubble class. The bubble template has remained the same. It was that easy for me to add a second bubble to the Processing sketch because of the way I organized the code with object oriented programming. 

So let me ask another question. What if I want the bubbles to be different sizes? No problem. In the constructor, that's where the variable r is initialized. I can make it a random value. 

Well, picked two very similar random values. Let's try that again. Eh, a little bit better. Now, what if I want them to start at a different location? I could also make the exposition random. 

There they are. They started in different locations-- kind of close to each other. Try again. Ooh, boy. Different locations, but all the way to the right. 

What if I really want to specify where they start? I want one on the left and one on the right of the Processing window? How would I do that? I know that I need to initialize the objects variables in the constructor. 

But in the constructor, I don't know which I am. I can't have it do something different. I mean, the random function works, but I can't set it to be a specific value. If I give it a specific value here, they both start with that value. This is where constructor arguments come into play. 

[MUSIC PLAYING] 

I've removed a lot of the extra details about draw and the other functions-- part of the bubble class from the whiteboard just to focus on the bubble constructor in the class and the initialization creation of the two bubble objects bub0 and bub1. Remember, I want Bob 0 to start at a pixel location maybe 100. 

And then I want bub1 to start at a pixel location along the horizontal axis-- maybe 500. Essentially, what I'm saying is I want to say bub0 equals a new bubble at x equals 100. bub1 equals a new bubble at x equals 500. So why don't I write the values 100 and the values 500 there inside the parentheses? 

I'm going to create a new bubble with an argument that is a floating point number to indicate the starting x position of the bubble. The constructor, if you remember, is a function just like update, or show, or edges. But it is a special function that always returns the new bubble object. 

If I'm calling a function, or in this case, calling the bubble constructor with an argument, I need to make sure there is a matching parameter. That means I need to define the type for the parameter-- it will be a float-- and then the name. 

Oh, this is where things get really wonky. So ultimately, what I want is to fill this value x with this value 100. So this variable, whatever I call it, is just going to be a temporary variable. This local variable to the bubble constructor-- the parameter to the bubble constructor-- that receives the value and immediately passes it to the important variable-- the instance variable, x. 

So since I'm thinking of it as a temporary variable, why don't I call it tempX. Then, I'm going to set x equal to tempX. Now, I could add a second one-- comma something, and then I could have a tempY, and set the value of y. 

But I don't have a lot of room on my whiteboard, and I want all the bubbles to start at the bottom anyway, so this is how I'll do it. Let me remind you one more time of the flow here. bub0 equals a new bubble with the value 100. 

The value 100 is then sent into the constructor. It fills the parameter tempX, and then the value of tempX is assigned to the property of that bubble, x. So bub0 has an x value of 100. 

Now, bub1-- same exact thing happens-- has an x value of 500. Let's put that into the code and see if it works. First step, add the parameter to the constructor. 

Set x Now equal to temp x. Coming back to the main sketch, I can add the arguments. Now to the bubble constructor-- 100, 500. Then, I can run the sketch. 

And there we go. 2 bubbles, one at pixel 100, one at pixel 500. Before I move on, I just want to say a couple more things about this. In my experience teaching Processing object oriented programming like this for many, many years, this whole thing about initializing variables inside of a class through constructor arguments is very confusing. 

It seems really weird to have this variable whose sole purpose is just to receive this value, and then immediately pass it to this other variable. Why can't this value just go directly into this variable? Well, this is actually one of the principles of object oriented programming that I would consider under that topic of encapsulation. 

One of the core principles of object oriented programming is that to operate an object, you never mess with the data directly. You just call the functions on that object. This has a lot of benefits. 

It's kind of way beyond anything we're doing right now, and it kind of doesn't matter right now. Oh, who cares if I'm going to access x directly or not, or what I'm going to do? But there is a level of protection here. 

If I wanted to set up some rules to make sure that a value that's passed in is constrained within a given range, then I can put all of that logic into the constructor. So this idea of sending the value in through the object's constructor is actually quite important and powerful. 

That said, in the same way that you call a function on an object-- bub0.update, bub0.show-- you can also access the variables of an object through the dot syntax. So if I really wanted to, I could say something like bub1.y equals 200. And now, if I run the sketch, that second bubble, bub1, is starting at the y value of 200. 

Ugh! So this is making me kind of uncomfortable. I don't recommend you write the code this way. It will work. And probably in some of my other examples, and future other videos, and tutorials and things that you might look at, there are reasons why it can be very convenient to just access those properties directly. As a constraint right now to practice, try not doing that, and instead initialize the variables through the object's constructor. 

So with that, here's something you could try. What about adding a second parameter to the objects constructor that sets the value of the radius? So I could say, hey, I want a very small bubble and a very large bubble. What would you need to do syntax-wise to make that happen? 

The next step I'll take is adding an array, (WHISPERING) which you could try to do right now if you want to. But don't worry. I'm about to do it. 

[MUSIC PLAYING] 

Hello again. You can see that I have added a second argument to the constructor to set the radius. We've got one bubble with a little radius of 20 and one larger bubble with a radius of 100. In the Bubble class, note how I renamed the parameters of the constructor _x and _r. 

It looks a little bit odd. Underscore is one of these weird special characters that you actually can use in a variable name, and you can even start a variable name with. And it's typically used maybe for, what I might consider, a throwaway variable or a variable that you don't want to change the value of and use. 

And in this case, that's exactly what these _x and _r are doing. They're just there to receive the value and pass it to the important variable, the actual x and the actual r. With that out of the way, let's implement an array of bubbles. 

First step, instead of individual variables, bub0 and bub1, I'm just going to have one variable called bubbles. I'm going to use the word bubbles-- bubble with a plural-- just to indicate to myself that it's going to be an array. But really, remember, variables can be anything you want to call them. 

I need to make sure I put the square brackets in to tell Processing that this is going to be an array. And now, here's where things get a little wonky. I need to both create the array and specify the size of the array, and then I need to individually go into each element and create a bubble object and place it there in the array. So up here, I'm going to say new Bubble, and let's just have 2 for right now. 

So that makes an array with two spots in it and just to ease our way in. We don't need a loop just yet. Let's individually create bubbles index 0 and bubbles index 1. Then, I need to call update, edges, and show on each one of those bubble objects in the array. 

And there we go. Exactly the same sketch I had before, only the two separate bubbles aren't two separate variables. They are inside of an array at index 0 and index 1. 

So I'm not going to add a third bubble or a fourth bubble here. If that's what I want to do, I really am going to want to use a for loop to iterate over all the elements of the array. So this is actually something you could try right now. Remember all that stuff we did with arrays and for loops? See if you could get it to work. I'll pause and wait, but then I'll come right back and implement it and show you how to do it. 

[KEYBOARD TYPING] 

Adding a for loop. Let me first do that only in draw. So around where I'm saying bubbles 0 and bubbles 1, I'm going to put a for loop. for-- now, instead of referring to specific indices, I don't need this second call to bubbles 1. And instead of 0, I want to say i. 

So the loop is going to start with i equals 0, call the function, set i equal to 1, call the functions. Once i gets to 2, we're done-- out of the loop. Same exact thing. It would also be better if, instead of hardcoding the value 2, I just accessed whatever the length of the array is. 

Let's try adding 10 bubbles. So the array will now have 10 elements in it. I do not want to initialize every single bubble individually, so I will also do a for loop in setup. Then, I'm going to say bubbles index i equals a new bubble. And let's just leave it at 100, comma, 20 for now. 

There we go. I have 10 bubbles all floating up, but I've lost something here. I lost the fact that I had the bubbles placed at different spots with different sizes. To be honest, it might make sense for me to right now just remove those constructor arguments and go back to initializing the variables with a random value. 

But I think this is kind of a nice opportunity for me to show you something that you can do to make use of that iterator i while you're initializing the elements of an array. For example, even though i is really just there to count over the index values of the array, there's no reason why I can't put i right here as the first argument to the constructor. Oh, look-- well, it kind of looks like they all started at the same spot, because pixels 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, they're kind of very close to each other. 

What if I were to multiply i times 10? So now, I'm starting the bubbles at pixel 0, 10, 20, 30, 40, 50, all the way up to 90. Pretty good. Let's try 50. Look at that. 

Ooh, let's add 50. And look how they're spaced out so nicely. So if, what I want to do, is initialize the variables with some regular spacing, I can use the fact that I'm counting through the array to do that. 

But I can also continue to use random. And since I have constructor arguments already, there's no reason for me to remove them, because I'm leaving open lots of different options by having them. But instead of hardcoding 20 right here, I could say random 20, comma, 40. So now, all the bubbles have a random radius between 20 and 40 pixels. 

Maybe you can read that line of code and understand it just by looking at it, but I find having these equations and other function calls inside of the arguments themselves to be kind of confusing. So just for readability purposes, let me pull those out and put them into separate local variables. And there we go. I've named those variables x and r, and that could be kind of confusing. 

But remember, just because I'm using the same name doesn't mean the variables have anything to do with each other. These variables are local only to the for loop. And I'm using them just to send values into the constructor. 

And what happens to those values? They get passed into the _x and _r variable, and those get passed into x and r. Here, the parameters should not be named x and r because they are being used within that same block of code, the constructor, and that would be a conflict. 

But I could have called them, like I did before, tempX and tempR, and everything works just as it should. I don't know. Maybe you have a better idea for what's a nice naming convention for your constructor arguments. I would love to hear about that in the comments. 

I'm getting close to the end of this very long video all about learning the foundational concepts of programming in Processing. Got a few more things I want to demonstrate. This is, though, a nice time to take a little pause, take a little breather. 

Maybe you could try enhancing this particular sketch with adding color, another property to the objects. Maybe what happens if you introduce a different kind of object? Could you have two classes and two arrays? Oh, my goodness! 

So many things you could do. Take it easy on yourself. When I come back, what I'm going to show you how to do-- and you could try this yourself-- is how to interact with these objects with the mouse. What if I want to click on each object and have their color change when I click on them? 

[MUSIC PLAYING] 

So while you were taking that break and I was taking that break, I added color to this sketch. Did you? If you did, wow, because I realized while I was doing it I forgot to cover something kind of important earlier when I was looking at variables. 

And that is what if I want to store a color in a variable? So the examples that I made previously, I would store the red, green, and blue values in separate variables. And then if I needed to call fill or stroke, I could just pass those variables into the function. But there is a data type in Processing called color that will store the red, green, and blue values together. 

I'm making the case to you that these are both equivalent. Here, three separate floating point values-- fill r, comma, g, comma, b. Here, one variable. Maybe I could come up with a better variable name than just call, but call for color. 

The data type of this variable is actually color. And I'm creating the color value with a function called color. So both of these things are built into Processing. 

There is a color function that receives three arguments, or four, or one depending on whether it's grayscale or has alpha-- creates the color itself, storing it in a variable of type color. And then I can just say fill that variable name. Now, perhaps there's a little bit of irony here in that I'm talking about this idea of packaging three variables into one in the section about object oriented programming. 

Because you could design your own Color class, and a color object would have three properties, and you could implement all this functionality to manipulate color. And that's definitely possible and kind of interesting, but that's not what's going on here. In Processing, Processing has a special data type called color, which is actually just an integer. 

When you call the color function and give it three different values, it takes those values and puts them together into one much larger number that Processing knows how to interpret and set the pixels to the color that you originally specified. There's a lot more to this. It has to do with bits, and bytes, and how numbers are stored in the computer's memory. 

But I think that's a topic for another time. I can try to make sure I include some reference material for reading more about that, and maybe even link to another video that I could make, or that I have already made about that particular topic. For now, what I want to focus on is the fact that there is a color data type and a function called color that can create a color value that I store in a variable. 

So now, coming back to this code, if I go into the Bubble class, you can see I've added a new variable of type color. And in the bubble constructor, I've created a pink color with some alpha. And then I'm calling fill and show with that color. I could have also had separate RGB properties of this bubble object. But I already had a value called r for radius, so let's use the color variable. 

Now, what if I want to do is, whenever I click on one of these objects, it changes color? So what if, inside the Bubble class, I add a new function, and I'm going to call it over? And I'll explain why I'm calling it over in a moment. 

My idea for this function is that it's going to receive two values, an x and a y and it's going to determine if that xy position is inside the circle. Only-- oh, boy. I do not want to call these variables x and y, because remember, the bubble has instance variables x and y. 

So because I know my intention is to use it with the mouse, I'm going to call it mx and my. I could access mouseX and mouseY directly in the Bubble class, but I'm not going to do that. And maybe I'll talk a little bit about why I've chosen not to do that in a moment. 

So now, the question becomes, how do I determine if that point, mx, comma, my is inside the bubble circle itself? And I guess, in a way, as we are wrapping up this video, I'm just giving you a smattering of some additional tips and tricks. It's a small selection. It's not comprehensive, but will allow you to do a little bit more with this bubble example than just draw a bunch of bubbles floating on the screen. 

So let's say I have a circle. I also have a radius, which is defined as the distance between the center of the circle and the exterior-- the perimeter of the circle. I'm calling that r. Now, I have a new point-- mx, comma, my. 

Maybe I clicked the mouse over here, so my point is mx, comma, my. Maybe I click the mouse over here, and my point is mx, comma, my. If I were to be able to calculate the distance between the center of the circle-- remember, this is xy-- and that point, mx, my, I can determine if that point is inside the circle. 

How? Let's call that distance d. And I'm just showing you two different examples of a d. If d is less than r, what? If the distance between the point and the center of the circle is less than the radius, that point must be inside the circle. 

If it's greater than the radius, it's outside the circle. So this is the code that I'll need to write, only I need to figure out how to calculate d. Well, guess what? There is a function in Processing called dist, for distance, that I can give four arguments-- the xy of one point and the xy of another. 

And this will return the distance between these two points. And I can store that in my variable d. Adding that into the code. And I'll just for now print out the message "mouse is over." 

So why did I write this as a function inside of the class? Ultimately, what I want to implement is something like a mousePressed function for the class. And you might have been thinking, oh, we have a function called mousePressed. Could I just right mouse pressed into the Bubble class, and anything in there will be executed when you press the mouse on the bubble object? 

It's a nice thought, but think about what Processing would have to do behind the scenes to do that. It would have to know so much about your code and your intentions. The only thing Processing can do is tell you that the mouse has been pressed and what the location of the mouse was when it was pressed, and that happens in the global function mousePressed. 

So I wrote a function in the Bubble class called over, and I can call that function when the mousePressed event happens. In other words, if I come back to the main program now, and I add mousePressed, what do I want to do? I want to loop through all of the bubble objects. 

And then I want to say bubbles index i over mouseX, mouseY. One of the reasons I'm showing this to you is to emphasize that those functions in a class are just like the functions we wrote earlier. You can pass them arguments. 

This is a way for you to communicate from one part of the code to another part of the code. And there's so much more to it, but this is a nice starting point. Let's run this sketch. And in theory, whenever I click the mouse on one of these bubbles, I should see a message down in the console if I've written the code correctly. 

So I'm first going to click over here where there are no bubbles. No message. Great. Now, let me click on this one. It's kind of big. 

Ah, yes! I'm seeing mouse is over multiple times in the console. It's working. OK, but I don't want to just print to the console. I want to change the color. And certainly, I could just do that right here. 

Let's do that right now, actually. And I'll give it a new random color-- just three random values, but leave the alpha hardcoded. Let's just leave green at 0 so it's some different shade of pink-purple. 

So you can see that any time I'm clicking on a bubble, the color changes. But this is a nice opportunity for me to show you a little bit more-- just to practice this idea of functions that return something, of different kinds of data types. What if what I actually want to do is write another function called changeColor? In other words, I want to really think about the code as even more modular than it currently is. 

So in this function, that's where I actually set the new value. So one option would be for me to just call changeColor here right now, and I could do that. Same result, but I want to show you something different. 

The function over, in my mind, is really not about changing the color. It's about one thing and one thing only-- knowing if any given point is over that bubble. So in order to constrain it to only that functionality, I'm going to have it return true when the point is over the bubble and false when it's not. 

But what did I miss? This function is no longer void. It's now a function that returns what? A Boolean. I can now say out here, if bubbles i over mouseX, mouseY-- what goes in a conditional statement? Anything that evaluates to true or false. 

This function over now evaluates to true or false. If it evaluates to true, I can say bubbles index i dot changeColor. So in a lot of ways, this is just an excuse for me to reinforce some things. One, I kind of forgot to tell you a little bit more about color, so let's look at that. 

There's lots more functions in Processing-- distance is just one example. Remember that mousePressed function? How could you use that with objects? And all that stuff about functions taking arguments and functions returning things, I'm showing you all of that just in this one particular scenario. 

But [CHUCKLES] I can't stop. Let me show you two more things about this particular example that I think would be nice to know about and help make the code a little bit more succinct. Personally, I love the way that I wrote this. 

If d is less than r, return true. Otherwise, return false. It says exactly what it's doing. It's a little bit long-winded, and I feel it's important for me to show you this because you'll see it in a lot of other examples. d is less than r is actually something itself that evaluates to true or false. 

So there's no reason for me to specifically ask what its value is and then say return true. I could just say return whatever you evaluate to. So in that case, I could write this function instead as return d is less than r. 

So if I had shown you this first, maybe that would have been a little bit confusing. But I do want to emphasize that return d is less than r is exactly the same as what is there commented out now-- return true or return false based on if d is less than r is true or false. One more thing. It's really good to practice using for loops and arrays, and understanding what the index value means, and how you count through all the elements of the array. And you can see how I was able to make use of the variable i in setup for initializing the exposition of every one of those bubbles. But this idea of saying, hey, I've got an array of things-- can I just do something to every element of the array-- is so common there is another way to write this loop that you might consider a little bit simpler to type or a little bit more clearer, and it's what's known as an enhanced loop. 

[MUSIC PLAYING] 

What if I were to say to you for every Bubble b, in the array bubbles, update, show, and display it? That's what I want to do. Here's the syntax for exactly that. 

For every Bubble b, in the array bubbles, update that bubble, check its edges, and show it. And b doesn't have to be b. I could have called it bub, or again, whatever I want to call it. Let's call it bub because that's what I used before when I had a single bubble object. 

Comment this out, run this code, and it's exactly the same thing. So just to cover this syntax, I have the variable, Bubble bub, which will stand in for every single bubble in the array. And then I have the array named bubbles. And I put those in a for loop with a colon in between. 

And then instead of having to say bubbles index i, I can just say bub.update, bub.edges, bub.show. The same exact loop could be used in mousePressed. I'll leave that as part of the code examples that I released with this video. 

You could give it a try right now if you want to pause and just adjust that syntax yourself. Don't worry. Before I go, I'm going to make a nice long list of all the things I didn't get to cover in this video series, and provide you with links, and resources, and ideas for what you could do next to continue your coding journey. 

One of the things you could choose to do is watch any one of my coding challenge videos, where I'll build a project from scratch. You have all of the foundation for just about every coding challenge now that I have on my channel. Varying degrees of difficulty. Your mileage may vary, but that's the idea. 

Let me give you a taste of that now. Let's build a project together. I'm going to start with this blank sketch right here. I'm going to make a burst of confetti to celebrate finishing this video, and then I'm going to ask you to make your own version of it and share it back with me on the Coding Train website, social media, wherever you can find me on the internet. 

[MUSIC PLAYING] 

So to create this burst of confetti, I want to have a lot of shapes-- probably just circles-- maybe I'll make them squares-- bursting out from this one spot in the Processing window. So I need an array, and an array of objects. I'm going to make a Confetti class. I'm going to add the constructor. 

I'm going to pass in an x and y location, and the confetti is going to have an x and a y. So now, let me make an array, and I'm going to put 100 elements in it. Usually, if I'm programming something, I'll make a single object first, but we just spent a lot of time doing that in the whole bubble section, so I think I'm going to start just with the array right now. 

Am I spelling confetti right? Oh, whoops. I made a mistake. Do you see the mistake I made? I forgot to specify that the confetti variable is of the type array. 

I need square brackets there as well. Now, let me set the background to white. And then how about we start by just adding a show function? I'm going to say fill 0, and I'm going to draw a square at xy of size 10, and that's it. 

Now, let me use that enhanced loop to say show all the confetti. So what I should see now when I run the sketch is 100 squares all in the center. c.show does not exist. Oh, I forgot to-- hmm, I forgot to put the return type, void. 

I also want to add rectMode center so that the square is drawn from the center point. Perfect. Now, if the confetti is going to burst out, I'm going to need variables to keep track of how the position changes along the x-axis and along the y-axis. So I'm going to add an xspeed and a yspeed. 

And let's set those when I make the confetti to 0, because how about I write a new function called burst that, when I call burst, the speed kicks in? And let's make it some random value between negative 10 and 10. And same for yspeed. 

And my idea here is, when I click the mouse, let's call burst on all of the confetti. So running the sketch, all the confetti is drawn at one point. I click the mouse, and in theory, it should burst because I set those variables, but I'm not using those variables anywhere. 

Guess what I need? I need an update function to change the value of x and y based on xspeed and yspeed. And if, in draw, I'm always calling update, then when I first run the sketch, xspeed and yspeed, remember, are 0. And only when I press the mouse do those values get filled with a new random number. Then I should see the confetti start to move. 

Oh, look at that burst! That was cool. Ta-dah! I need to do more. I want the confetti to fall down as if there were gravity. This merits a longer discussion, and I have a whole set of videos about doing physics simulation that you can find linked in the video description. 

But right now, basically, what I'm saying is that in addition to the y value changing, I want the yspeed value to also change, because the objects-- the confetti are going to be pulled down more and more every frame. yspeed equals yspeed plus-- let's just say a little bit-- 0.01. Oh, it's already falling. 

We burst it. So one thing that is, that is happening immediately. So now, I need this concept of the confetti only actually kicking into gear the moment that I click the mouse. There's probably a lot of different ways you could approach this. What I'm thinking about right now is having a Boolean variable, and I'll call it partyTime. 

[CHUCKLES] 

[VIDEO PLAYBACK] 

- Party time. Excellent. 

- Excellent. And I'll set it equal to false. 

[END PLAYBACK] 

So in draw, I'm actually only going to run through all the confetti if partyTime is true. So this for loop can actually live inside of an if statement. If it's partyTime, show and update all the confetti. 

And then when I click the mouse, what do I want to happen? partyTime should equal true. Let's see how this goes. Hey, that kind of worked. 

I mean, it did work, but I don't-- there are some things about it that I don't like. Number one is the gravity should be much stronger. Maybe the values of xspeed and yspeed should be a little bit smaller. 

That's great. Another thing I would like to do is have all of the confetti start wherever I click the mouse. So burst could actually be defined with two parameters. I'll call it mx and my. 

And when they burst, I should pass in mouseX and mouseY. And that's where I'll set. Even though I'm setting the confetti's initial values in the constructor, I'm going to reset those values here. 

And in truth, maybe their initial values shouldn't get set with the constructor, and I should just set them to somewhere way off the Processing window as initial values. So here, I no longer need width divided by 2, height divided by 2. Instead, when I click the mouse, partyTime is true, and the confetti is going to burst starting at mouseX, mouseY. 

Click-- there we go. And watch this. What happens if I click again? Look, I get the confetti again. Wow. I mean, here's the thing. 

It's not as magical as you might think, because if I click really fast, it's reusing the same objects. It's not creating a whole new set of objects. Oh, that's something that I didn't get to cover. 

So many things I didn't get to cover. What if I want those confetti squares to spin and rotate? I didn't talk about transformations in Processing. How do you rotate a shape? 

What if I want to add elements to the array? So every time I click, I create a new set of confetti-- 100 more, 100 more. Suddenly, the array has 200, then it has 300. 

Well, I can't actually do that easily with a regular array. I need to use something called an ArrayList. That's another thing I didn't cover. I have one more segment. I need to take a break and organize my thoughts, and figure out what it is I want to tell you about. 

I'll be right back. I'll have changed my clothes. It'll be a new day. I'll probably do this tomorrow, and I'll see you soon. 

[MUSIC PLAYING] 

Hi, you are at the end of this very, very long video all about learning to program in Processing. Congratulations for making it through. I hope you enjoyed the little mini-project there at the end. I hope you're already thinking about making something to submit to the Coding Train passenger showcase. 

So I'm here just to wrap things up, tie a little bow around this video, and talk about what it is you might want to do next. So maybe you're done. That's totally fine. Very reasonable. 

You don't have to watch any more videos-- do any more programming ever in your life, if you don't want to. But if you are interested in doing more, there is a ton of stuff that I left out, just to name a few things. I didn't talk about loading images, and reading the pixels of the image. 

I didn't talk about using the Processing 3D renderer, or about how transformations work, which refer to the functions translate, and rotate, and scale. I didn't look at data, how to load text, or how to load a spreadsheet, and how to visualize that data into your code. How to connect to an API, meaning another server somewhere on the web that is feeding data that you could connect to. 

[CHIMES] 

I didn't talk about playing sound, or loading video, or about typography, or simulation and physics, and all sorts of other things that you could do with code in Processing or other environments. But good news for you. If you enjoyed this series, I have so many more videos that touch on a lot of these concepts. 

So I will list with this video a lot of next things that you could look at. One thing I might just suggest is go to the Coding Train Coding Challenges page. You can sort, and search, and find all the project videos. 

You are now set up to watch any of those, although I should warn you that many of them use JavaScript. So you might want to learn some of the basics of p5.js before going to those videos, which I also have videos about. So there are so many different paths you could take. 

Obviously, you could go to a different language. Python might be one that you're interested in. You might want to find other resources, and books, and videos. I'll try to collect as much as I possibly can. 

And the Coding Train Discord is a great reference in place for you to chat about this and discuss this. But really, the main thing that I want to say to you is, thank you. It means a lot to me that you sat through all of this, that you're trying, that you're learning to program. 

I don't know how many people will watch this. Who knows? But I would love to hear from every single one of you. So join the Discord, say hi. 

Say hi on social media. If you've made something, send me a screenshot, a short little clip. Those are the things that I love to get. And that's it. That's all I got for you. Thanks. 

I'll see you again in 10 years. 2034 is about when I'll be redoing this series again. We'll see. Bye. Thanks for watching. 

[MUSIC PLAYING] 

[SQUEAKY WHEELS] 

[TELEMETRY BEEP] 

